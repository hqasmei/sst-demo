/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-xml-parser@4.2.5";
exports.ids = ["vendor-chunks/fast-xml-parser@4.2.5"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/fxp.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/fxp.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst validator = __webpack_require__(/*! ./validator */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/validator.js\");\nconst XMLParser = __webpack_require__(/*! ./xmlparser/XMLParser */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\");\nconst XMLBuilder = __webpack_require__(/*! ./xmlbuilder/json2xml */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\");\nmodule.exports = {\n    XMLParser: XMLParser,\n    XMLValidator: validator,\n    XMLBuilder: XMLBuilder\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy9meHAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUMxQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQztBQUUzQkcsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZILFdBQVdBO0lBQ1hJLGNBQWNOO0lBQ2RHLFlBQVlBO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy9meHAuanM/NmVlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5jb25zdCBYTUxQYXJzZXIgPSByZXF1aXJlKCcuL3htbHBhcnNlci9YTUxQYXJzZXInKTtcbmNvbnN0IFhNTEJ1aWxkZXIgPSByZXF1aXJlKCcuL3htbGJ1aWxkZXIvanNvbjJ4bWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFhNTFBhcnNlcjogWE1MUGFyc2VyLFxuICBYTUxWYWxpZGF0b3I6IHZhbGlkYXRvcixcbiAgWE1MQnVpbGRlcjogWE1MQnVpbGRlclxufSJdLCJuYW1lcyI6WyJ2YWxpZGF0b3IiLCJyZXF1aXJlIiwiWE1MUGFyc2VyIiwiWE1MQnVpbGRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJYTUxWYWxpZGF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/fxp.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/util.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/util.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst nameStartChar = \":A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\nconst nameChar = nameStartChar + \"\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\nconst nameRegexp = \"[\" + nameStartChar + \"][\" + nameChar + \"]*\";\nconst regexName = new RegExp(\"^\" + nameRegexp + \"$\");\nconst getAllMatches = function(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while(match){\n        const allmatches = [];\n        allmatches.startIndex = regex.lastIndex - match[0].length;\n        const len = match.length;\n        for(let index = 0; index < len; index++){\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n};\nconst isName = function(string) {\n    const match = regexName.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\nexports.isExist = function(v) {\n    return typeof v !== \"undefined\";\n};\nexports.isEmptyObject = function(obj) {\n    return Object.keys(obj).length === 0;\n};\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */ exports.merge = function(target, a, arrayMode) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            if (arrayMode === \"strict\") {\n                target[keys[i]] = [\n                    a[keys[i]]\n                ];\n            } else {\n                target[keys[i]] = a[keys[i]];\n            }\n        }\n    }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */ exports.getValue = function(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n};\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsZ0JBQWdCO0FBQ3RCLE1BQU1DLFdBQVdELGdCQUFnQjtBQUNqQyxNQUFNRSxhQUFhLE1BQU1GLGdCQUFnQixPQUFPQyxXQUFXO0FBQzNELE1BQU1FLFlBQVksSUFBSUMsT0FBTyxNQUFNRixhQUFhO0FBRWhELE1BQU1HLGdCQUFnQixTQUFTQyxNQUFNLEVBQUVDLEtBQUs7SUFDMUMsTUFBTUMsVUFBVSxFQUFFO0lBQ2xCLElBQUlDLFFBQVFGLE1BQU1HLElBQUksQ0FBQ0o7SUFDdkIsTUFBT0csTUFBTztRQUNaLE1BQU1FLGFBQWEsRUFBRTtRQUNyQkEsV0FBV0MsVUFBVSxHQUFHTCxNQUFNTSxTQUFTLEdBQUdKLEtBQUssQ0FBQyxFQUFFLENBQUNLLE1BQU07UUFDekQsTUFBTUMsTUFBTU4sTUFBTUssTUFBTTtRQUN4QixJQUFLLElBQUlFLFFBQVEsR0FBR0EsUUFBUUQsS0FBS0MsUUFBUztZQUN4Q0wsV0FBV00sSUFBSSxDQUFDUixLQUFLLENBQUNPLE1BQU07UUFDOUI7UUFDQVIsUUFBUVMsSUFBSSxDQUFDTjtRQUNiRixRQUFRRixNQUFNRyxJQUFJLENBQUNKO0lBQ3JCO0lBQ0EsT0FBT0U7QUFDVDtBQUVBLE1BQU1VLFNBQVMsU0FBU1osTUFBTTtJQUM1QixNQUFNRyxRQUFRTixVQUFVTyxJQUFJLENBQUNKO0lBQzdCLE9BQU8sQ0FBRUcsQ0FBQUEsVUFBVSxRQUFRLE9BQU9BLFVBQVUsV0FBVTtBQUN4RDtBQUVBVSxlQUFlLEdBQUcsU0FBU0UsQ0FBQztJQUMxQixPQUFPLE9BQU9BLE1BQU07QUFDdEI7QUFFQUYscUJBQXFCLEdBQUcsU0FBU0ksR0FBRztJQUNsQyxPQUFPQyxPQUFPQyxJQUFJLENBQUNGLEtBQUtULE1BQU0sS0FBSztBQUNyQztBQUVBOzs7O0NBSUMsR0FDREssYUFBYSxHQUFHLFNBQVNRLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQzNDLElBQUlELEdBQUc7UUFDTCxNQUFNSCxPQUFPRCxPQUFPQyxJQUFJLENBQUNHLElBQUkseUNBQXlDO1FBQ3RFLE1BQU1iLE1BQU1VLEtBQUtYLE1BQU0sRUFBRSxzQkFBc0I7UUFDL0MsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJZixLQUFLZSxJQUFLO1lBQzVCLElBQUlELGNBQWMsVUFBVTtnQkFDMUJGLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDSyxFQUFFLENBQUMsR0FBRztvQkFBRUYsQ0FBQyxDQUFDSCxJQUFJLENBQUNLLEVBQUUsQ0FBQztpQkFBRTtZQUNsQyxPQUFPO2dCQUNMSCxNQUFNLENBQUNGLElBQUksQ0FBQ0ssRUFBRSxDQUFDLEdBQUdGLENBQUMsQ0FBQ0gsSUFBSSxDQUFDSyxFQUFFLENBQUM7WUFDOUI7UUFDRjtJQUNGO0FBQ0Y7QUFDQTs7RUFFRSxHQUVGWCxnQkFBZ0IsR0FBRyxTQUFTRSxDQUFDO0lBQzNCLElBQUlGLFFBQVFDLE9BQU8sQ0FBQ0MsSUFBSTtRQUN0QixPQUFPQTtJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLDRDQUE0QztBQUM1QywwQ0FBMEM7QUFFMUNGLGNBQWMsR0FBR0Q7QUFDakJDLHFCQUFxQixHQUFHZDtBQUN4QmMsa0JBQWtCLEdBQUdqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC14bWwtcGFyc2VyQDQuMi41L25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3V0aWwuanM/YmIxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5hbWVTdGFydENoYXIgPSAnOkEtWmEtel9cXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG5jb25zdCBuYW1lQ2hhciA9IG5hbWVTdGFydENoYXIgKyAnXFxcXC0uXFxcXGRcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5jb25zdCBuYW1lUmVnZXhwID0gJ1snICsgbmFtZVN0YXJ0Q2hhciArICddWycgKyBuYW1lQ2hhciArICddKidcbmNvbnN0IHJlZ2V4TmFtZSA9IG5ldyBSZWdFeHAoJ14nICsgbmFtZVJlZ2V4cCArICckJyk7XG5cbmNvbnN0IGdldEFsbE1hdGNoZXMgPSBmdW5jdGlvbihzdHJpbmcsIHJlZ2V4KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhzdHJpbmcpO1xuICB3aGlsZSAobWF0Y2gpIHtcbiAgICBjb25zdCBhbGxtYXRjaGVzID0gW107XG4gICAgYWxsbWF0Y2hlcy5zdGFydEluZGV4ID0gcmVnZXgubGFzdEluZGV4IC0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IGxlbiA9IG1hdGNoLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICBhbGxtYXRjaGVzLnB1c2gobWF0Y2hbaW5kZXhdKTtcbiAgICB9XG4gICAgbWF0Y2hlcy5wdXNoKGFsbG1hdGNoZXMpO1xuICAgIG1hdGNoID0gcmVnZXguZXhlYyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufTtcblxuY29uc3QgaXNOYW1lID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIGNvbnN0IG1hdGNoID0gcmVnZXhOYW1lLmV4ZWMoc3RyaW5nKTtcbiAgcmV0dXJuICEobWF0Y2ggPT09IG51bGwgfHwgdHlwZW9mIG1hdGNoID09PSAndW5kZWZpbmVkJyk7XG59O1xuXG5leHBvcnRzLmlzRXhpc3QgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5leHBvcnRzLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBDb3B5IGFsbCB0aGUgcHJvcGVydGllcyBvZiBhIGludG8gYi5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IGFcbiAqL1xuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKHRhcmdldCwgYSwgYXJyYXlNb2RlKSB7XG4gIGlmIChhKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpOyAvLyB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBvd24gcHJvcGVydGllc1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoOyAvL2Rvbid0IG1ha2UgaXQgaW5saW5lXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFycmF5TW9kZSA9PT0gJ3N0cmljdCcpIHtcbiAgICAgICAgdGFyZ2V0W2tleXNbaV1dID0gWyBhW2tleXNbaV1dIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5c1tpXV0gPSBhW2tleXNbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qIGV4cG9ydHMubWVyZ2UgPWZ1bmN0aW9uIChiLGEpe1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihiLGEpO1xufSAqL1xuXG5leHBvcnRzLmdldFZhbHVlID0gZnVuY3Rpb24odikge1xuICBpZiAoZXhwb3J0cy5pc0V4aXN0KHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG4vLyBjb25zdCBmYWtlQ2FsbCA9IGZ1bmN0aW9uKGEpIHtyZXR1cm4gYTt9O1xuLy8gY29uc3QgZmFrZUNhbGxOb1JldHVybiA9IGZ1bmN0aW9uKCkge307XG5cbmV4cG9ydHMuaXNOYW1lID0gaXNOYW1lO1xuZXhwb3J0cy5nZXRBbGxNYXRjaGVzID0gZ2V0QWxsTWF0Y2hlcztcbmV4cG9ydHMubmFtZVJlZ2V4cCA9IG5hbWVSZWdleHA7XG4iXSwibmFtZXMiOlsibmFtZVN0YXJ0Q2hhciIsIm5hbWVDaGFyIiwibmFtZVJlZ2V4cCIsInJlZ2V4TmFtZSIsIlJlZ0V4cCIsImdldEFsbE1hdGNoZXMiLCJzdHJpbmciLCJyZWdleCIsIm1hdGNoZXMiLCJtYXRjaCIsImV4ZWMiLCJhbGxtYXRjaGVzIiwic3RhcnRJbmRleCIsImxhc3RJbmRleCIsImxlbmd0aCIsImxlbiIsImluZGV4IiwicHVzaCIsImlzTmFtZSIsImV4cG9ydHMiLCJpc0V4aXN0IiwidiIsImlzRW1wdHlPYmplY3QiLCJvYmoiLCJPYmplY3QiLCJrZXlzIiwibWVyZ2UiLCJ0YXJnZXQiLCJhIiwiYXJyYXlNb2RlIiwiaSIsImdldFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/validator.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/validator.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/util.js\");\nconst defaultOptions = {\n    allowBooleanAttributes: false,\n    unpairedTags: []\n};\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n    options = Object.assign({}, defaultOptions, options);\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n    const tags = [];\n    let tagFound = false;\n    //indicates that the root tag has been closed (aka. depth 0 has been reached)\n    let reachedRoot = false;\n    if (xmlData[0] === \"\\uFEFF\") {\n        // check for byte order mark (BOM)\n        xmlData = xmlData.substr(1);\n    }\n    for(let i = 0; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\" && xmlData[i + 1] === \"?\") {\n            i += 2;\n            i = readPI(xmlData, i);\n            if (i.err) return i;\n        } else if (xmlData[i] === \"<\") {\n            //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            let tagStartPos = i;\n            i++;\n            if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {\n                    //closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for(; i < xmlData.length && xmlData[i] !== \">\" && xmlData[i] !== \" \" && xmlData[i] !== \"\t\" && xmlData[i] !== \"\\n\" && xmlData[i] !== \"\\r\"; i++){\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n                if (tagName[tagName.length - 1] === \"/\") {\n                    //self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    //continue;\n                    i--;\n                }\n                if (!validateTagName(tagName)) {\n                    let msg;\n                    if (tagName.trim().length === 0) {\n                        msg = \"Invalid space after '<'.\";\n                    } else {\n                        msg = \"Tag '\" + tagName + \"' is an invalid name.\";\n                    }\n                    return getErrorObject(\"InvalidTag\", msg, getLineNumberForPosition(xmlData, i));\n                }\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return getErrorObject(\"InvalidAttr\", \"Attributes for '\" + tagName + \"' have open quote.\", getLineNumberForPosition(xmlData, i));\n                }\n                let attrStr = result.value;\n                i = result.index;\n                if (attrStr[attrStr.length - 1] === \"/\") {\n                    //self closing tag\n                    const attrStrStart = i - attrStr.length;\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                    //continue; //text may presents after self closing tag\n                    } else {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n                    }\n                } else if (closingTag) {\n                    if (!result.tagClosed) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n                    } else if (attrStr.trim().length > 0) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg.tagName) {\n                            let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n                            return getErrorObject(\"InvalidTag\", \"Expected closing tag '\" + otg.tagName + \"' (opened in line \" + openPos.line + \", col \" + openPos.col + \") instead of closing tag '\" + tagName + \"'.\", getLineNumberForPosition(xmlData, tagStartPos));\n                        }\n                        //when there are no more tags, we reached the root level.\n                        if (tags.length == 0) {\n                            reachedRoot = true;\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n                    }\n                    //if the root level has been reached before ...\n                    if (reachedRoot === true) {\n                        return getErrorObject(\"InvalidXml\", \"Multiple possible root nodes found.\", getLineNumberForPosition(xmlData, i));\n                    } else if (options.unpairedTags.indexOf(tagName) !== -1) {\n                    //don't push into stack\n                    } else {\n                        tags.push({\n                            tagName,\n                            tagStartPos\n                        });\n                    }\n                    tagFound = true;\n                }\n                //skip tag text value\n                //It may include comments and CDATA value\n                for(i++; i < xmlData.length; i++){\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {\n                            //comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else if (xmlData[i + 1] === \"?\") {\n                            i = readPI(xmlData, ++i);\n                            if (i.err) return i;\n                        } else {\n                            break;\n                        }\n                    } else if (xmlData[i] === \"&\") {\n                        const afterAmp = validateAmpersand(xmlData, i);\n                        if (afterAmp == -1) return getErrorObject(\"InvalidChar\", \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n                        i = afterAmp;\n                    } else {\n                        if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n                            return getErrorObject(\"InvalidXml\", \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n                        }\n                    }\n                } //end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (isWhiteSpace(xmlData[i])) {\n                continue;\n            }\n            return getErrorObject(\"InvalidChar\", \"char '\" + xmlData[i] + \"' is not expected.\", getLineNumberForPosition(xmlData, i));\n        }\n    }\n    if (!tagFound) {\n        return getErrorObject(\"InvalidXml\", \"Start tag expected.\", 1);\n    } else if (tags.length == 1) {\n        return getErrorObject(\"InvalidTag\", \"Unclosed tag '\" + tags[0].tagName + \"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n    } else if (tags.length > 0) {\n        return getErrorObject(\"InvalidXml\", \"Invalid '\" + JSON.stringify(tags.map((t)=>t.tagName), null, 4).replace(/\\r?\\n/g, \"\") + \"' found.\", {\n            line: 1,\n            col: 1\n        });\n    }\n    return true;\n};\nfunction isWhiteSpace(char) {\n    return char === \" \" || char === \"\t\" || char === \"\\n\" || char === \"\\r\";\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */ function readPI(xmlData, i) {\n    const start = i;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {\n            //tagname\n            const tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return getErrorObject(\"InvalidXml\", \"XML declaration allowed only at the start of the document.\", getLineNumberForPosition(xmlData, i));\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {\n        //comment\n        for(i += 3; i < xmlData.length; i++){\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 && xmlData[i + 1] === \"D\" && xmlData[i + 2] === \"O\" && xmlData[i + 3] === \"C\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"Y\" && xmlData[i + 6] === \"P\" && xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\") {\n                angleBracketsCount++;\n            } else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 && xmlData[i + 1] === \"[\" && xmlData[i + 2] === \"C\" && xmlData[i + 3] === \"D\" && xmlData[i + 4] === \"A\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"A\" && xmlData[i + 7] === \"[\") {\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n    return i;\n}\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */ function readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    let tagClosed = false;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                tagClosed = true;\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n    return {\n        value: attrStr,\n        index: i,\n        tagClosed: tagClosed\n    };\n}\n/**\n * Select all the attributes whether valid or invalid.\n */ const validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n    //if(attrStr.trim().length === 0) return true; //empty string\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = {};\n    for(let i = 0; i < matches.length; i++){\n        if (matches[i][1].length === 0) {\n            //nospace before attribute name: a=\"sd\"b=\"saf\"\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' has no space in starting.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' is without value.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n            //independent attribute: ab\n            return getErrorObject(\"InvalidAttr\", \"boolean attribute '\" + matches[i][2] + \"' is not allowed.\", getPositionFromMatch(matches[i]));\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */ const attrName = matches[i][2];\n        if (!validateAttrName(attrName)) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is an invalid name.\", getPositionFromMatch(matches[i]));\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {\n            //check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is repeated.\", getPositionFromMatch(matches[i]));\n        }\n    }\n    return true;\n}\nfunction validateNumberAmpersand(xmlData, i) {\n    let re = /\\d/;\n    if (xmlData[i] === \"x\") {\n        i++;\n        re = /[\\da-fA-F]/;\n    }\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \";\") return i;\n        if (!xmlData[i].match(re)) break;\n    }\n    return -1;\n}\nfunction validateAmpersand(xmlData, i) {\n    // https://www.w3.org/TR/xml/#dt-charref\n    i++;\n    if (xmlData[i] === \";\") return -1;\n    if (xmlData[i] === \"#\") {\n        i++;\n        return validateNumberAmpersand(xmlData, i);\n    }\n    let count = 0;\n    for(; i < xmlData.length; i++, count++){\n        if (xmlData[i].match(/\\w/) && count < 20) continue;\n        if (xmlData[i] === \";\") break;\n        return -1;\n    }\n    return i;\n}\nfunction getErrorObject(code, message, lineNumber) {\n    return {\n        err: {\n            code: code,\n            msg: message,\n            line: lineNumber.line || lineNumber,\n            col: lineNumber.col\n        }\n    };\n}\nfunction validateAttrName(attrName) {\n    return util.isName(attrName);\n}\n// const startsWithXML = /^xml/i;\nfunction validateTagName(tagname) {\n    return util.isName(tagname) /* && !tagname.match(startsWithXML) */ ;\n}\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n    const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n    return {\n        line: lines.length,\n        // column number is last line's length + 1, because column numbering starts at 1:\n        col: lines[lines.length - 1].length + 1\n    };\n}\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n    return match.startIndex + match[1].length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNQyxpQkFBaUI7SUFDckJDLHdCQUF3QjtJQUN4QkMsY0FBYyxFQUFFO0FBQ2xCO0FBRUEscUVBQXFFO0FBQ3JFQyxnQkFBZ0IsR0FBRyxTQUFVRSxPQUFPLEVBQUVDLE9BQU87SUFDM0NBLFVBQVVDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdSLGdCQUFnQk07SUFFNUMsc0VBQXNFO0lBQ3RFLCtFQUErRTtJQUMvRSw2RkFBNkY7SUFDN0YsTUFBTUcsT0FBTyxFQUFFO0lBQ2YsSUFBSUMsV0FBVztJQUVmLDZFQUE2RTtJQUM3RSxJQUFJQyxjQUFjO0lBRWxCLElBQUlOLE9BQU8sQ0FBQyxFQUFFLEtBQUssVUFBVTtRQUMzQixrQ0FBa0M7UUFDbENBLFVBQVVBLFFBQVFPLE1BQU0sQ0FBQztJQUMzQjtJQUVBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUixRQUFRUyxNQUFNLEVBQUVELElBQUs7UUFFdkMsSUFBSVIsT0FBTyxDQUFDUSxFQUFFLEtBQUssT0FBT1IsT0FBTyxDQUFDUSxJQUFFLEVBQUUsS0FBSyxLQUFLO1lBQzlDQSxLQUFHO1lBQ0hBLElBQUlFLE9BQU9WLFNBQVFRO1lBQ25CLElBQUlBLEVBQUVHLEdBQUcsRUFBRSxPQUFPSDtRQUNwQixPQUFNLElBQUlSLE9BQU8sQ0FBQ1EsRUFBRSxLQUFLLEtBQUs7WUFDNUIsaUJBQWlCO1lBQ2pCLGlFQUFpRTtZQUNqRSxJQUFJSSxjQUFjSjtZQUNsQkE7WUFFQSxJQUFJUixPQUFPLENBQUNRLEVBQUUsS0FBSyxLQUFLO2dCQUN0QkEsSUFBSUssb0JBQW9CYixTQUFTUTtnQkFDakM7WUFDRixPQUFPO2dCQUNMLElBQUlNLGFB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O1FBQ3JCO0lBQ0Y7QUFDRjtBQUVBLFNBQVMwQixpQkFBaUJELFFBQVE7SUFDaEMsT0FBT3BFLEtBQUs2RSxNQUFNLENBQUNUO0FBQ3JCO0FBRUEsaUNBQWlDO0FBRWpDLFNBQVMzQyxnQkFBZ0IrQixPQUFPO0lBQzlCLE9BQU94RCxLQUFLNkUsTUFBTSxDQUFDckIsU0FBUyxvQ0FBb0M7QUFDbEU7QUFFQSw0RUFBNEU7QUFDNUUsU0FBUzVCLHlCQUF5QnJCLE9BQU8sRUFBRTBCLEtBQUs7SUFDOUMsTUFBTTZDLFFBQVF2RSxRQUFRaUIsU0FBUyxDQUFDLEdBQUdTLE9BQU84QyxLQUFLLENBQUM7SUFDaEQsT0FBTztRQUNMekMsTUFBTXdDLE1BQU05RCxNQUFNO1FBRWxCLGlGQUFpRjtRQUNqRjJCLEtBQUttQyxLQUFLLENBQUNBLE1BQU05RCxNQUFNLEdBQUcsRUFBRSxDQUFDQSxNQUFNLEdBQUc7SUFDeEM7QUFDRjtBQUVBLG1GQUFtRjtBQUNuRixTQUFTa0QscUJBQXFCTyxLQUFLO0lBQ2pDLE9BQU9BLE1BQU1PLFVBQVUsR0FBR1AsS0FBSyxDQUFDLEVBQUUsQ0FBQ3pELE1BQU07QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy92YWxpZGF0b3IuanM/YmE0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsbG93Qm9vbGVhbkF0dHJpYnV0ZXM6IGZhbHNlLCAvL0EgdGFnIGNhbiBoYXZlIGF0dHJpYnV0ZXMgd2l0aG91dCBhbnkgdmFsdWVcbiAgdW5wYWlyZWRUYWdzOiBbXVxufTtcblxuLy9jb25zdCB0YWdzUGF0dGVybiA9IG5ldyBSZWdFeHAoXCI8XFxcXC8/KFtcXFxcdzpcXFxcLV9cXC5dKylcXFxccypcXC8/PlwiLFwiZ1wiKTtcbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoeG1sRGF0YSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSxcIlwiKTsvL21ha2UgaXQgc2luZ2xlIGxpbmVcbiAgLy94bWxEYXRhID0geG1sRGF0YS5yZXBsYWNlKC8oXlxccyo8XFw/eG1sLio/XFw/PikvZyxcIlwiKTsvL1JlbW92ZSBYTUwgc3RhcnRpbmcgdGFnXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKDwhRE9DVFlQRVtcXHNcXHdcXFwiXFwuXFwvXFwtXFw6XSsoXFxbLipcXF0pKlxccyo+KS9nLFwiXCIpOy8vUmVtb3ZlIERPQ1RZUEVcbiAgY29uc3QgdGFncyA9IFtdO1xuICBsZXQgdGFnRm91bmQgPSBmYWxzZTtcblxuICAvL2luZGljYXRlcyB0aGF0IHRoZSByb290IHRhZyBoYXMgYmVlbiBjbG9zZWQgKGFrYS4gZGVwdGggMCBoYXMgYmVlbiByZWFjaGVkKVxuICBsZXQgcmVhY2hlZFJvb3QgPSBmYWxzZTtcblxuICBpZiAoeG1sRGF0YVswXSA9PT0gJ1xcdWZlZmYnKSB7XG4gICAgLy8gY2hlY2sgZm9yIGJ5dGUgb3JkZXIgbWFyayAoQk9NKVxuICAgIHhtbERhdGEgPSB4bWxEYXRhLnN1YnN0cigxKTtcbiAgfVxuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnICYmIHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7XG4gICAgICBpKz0yO1xuICAgICAgaSA9IHJlYWRQSSh4bWxEYXRhLGkpO1xuICAgICAgaWYgKGkuZXJyKSByZXR1cm4gaTtcbiAgICB9ZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAvL3N0YXJ0aW5nIG9mIHRhZ1xuICAgICAgLy9yZWFkIHVudGlsIHlvdSByZWFjaCB0byAnPicgYXZvaWRpbmcgYW55ICc+JyBpbiBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgIGxldCB0YWdTdGFydFBvcyA9IGk7XG4gICAgICBpKys7XG4gICAgICBcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnIScpIHtcbiAgICAgICAgaSA9IHJlYWRDb21tZW50QW5kQ0RBVEEoeG1sRGF0YSwgaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNsb3NpbmdUYWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICcvJykge1xuICAgICAgICAgIC8vY2xvc2luZyB0YWdcbiAgICAgICAgICBjbG9zaW5nVGFnID0gdHJ1ZTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWFkIHRhZ25hbWVcbiAgICAgICAgbGV0IHRhZ05hbWUgPSAnJztcbiAgICAgICAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aCAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICc+JyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICcgJyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICdcXHQnICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJ1xcbicgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnXFxyJzsgaSsrXG4gICAgICAgICkge1xuICAgICAgICAgIHRhZ05hbWUgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50cmltKCk7XG4gICAgICAgIC8vY29uc29sZS5sb2codGFnTmFtZSk7XG5cbiAgICAgICAgaWYgKHRhZ05hbWVbdGFnTmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy9zZWxmIGNsb3NpbmcgdGFnIHdpdGhvdXQgYXR0cmlidXRlc1xuICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnN1YnN0cmluZygwLCB0YWdOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIC8vY29udGludWU7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsaWRhdGVUYWdOYW1lKHRhZ05hbWUpKSB7XG4gICAgICAgICAgbGV0IG1zZztcbiAgICAgICAgICBpZiAodGFnTmFtZS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtc2cgPSBcIkludmFsaWQgc3BhY2UgYWZ0ZXIgJzwnLlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtc2cgPSBcIlRhZyAnXCIrdGFnTmFtZStcIicgaXMgYW4gaW52YWxpZCBuYW1lLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLCBtc2csIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkQXR0cmlidXRlU3RyKHhtbERhdGEsIGkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZXMgZm9yICdcIit0YWdOYW1lK1wiJyBoYXZlIG9wZW4gcXVvdGUuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF0dHJTdHIgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGkgPSByZXN1bHQuaW5kZXg7XG5cbiAgICAgICAgaWYgKGF0dHJTdHJbYXR0clN0ci5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy9zZWxmIGNsb3NpbmcgdGFnXG4gICAgICAgICAgY29uc3QgYXR0clN0clN0YXJ0ID0gaSAtIGF0dHJTdHIubGVuZ3RoO1xuICAgICAgICAgIGF0dHJTdHIgPSBhdHRyU3RyLnN1YnN0cmluZygwLCBhdHRyU3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0ZUF0dHJpYnV0ZVN0cmluZyhhdHRyU3RyLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoaXNWYWxpZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGFnRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgLy9jb250aW51ZTsgLy90ZXh0IG1heSBwcmVzZW50cyBhZnRlciBzZWxmIGNsb3NpbmcgdGFnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vdGhlIHJlc3VsdCBmcm9tIHRoZSBuZXN0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGVycm9yIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL2luIG9yZGVyIHRvIGdldCB0aGUgJ3RydWUnIGVycm9yIGxpbmUsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlIGJlZ2lucyAoaSAtIGF0dHJTdHIubGVuZ3RoKSBhbmQgdGhlbiBhZGQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL3RoaXMgZ2l2ZXMgdXMgdGhlIGFic29sdXRlIGluZGV4IGluIHRoZSBlbnRpcmUgeG1sLCB3aGljaCB3ZSBjYW4gdXNlIHRvIGZpbmQgdGhlIGxpbmUgYXQgbGFzdFxuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KGlzVmFsaWQuZXJyLmNvZGUsIGlzVmFsaWQuZXJyLm1zZywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGF0dHJTdHJTdGFydCArIGlzVmFsaWQuZXJyLmxpbmUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2xvc2luZ1RhZykge1xuICAgICAgICAgIGlmICghcmVzdWx0LnRhZ0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJDbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicgZG9lc24ndCBoYXZlIHByb3BlciBjbG9zaW5nLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0clN0ci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJDbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicgY2FuJ3QgaGF2ZSBhdHRyaWJ1dGVzIG9yIGludmFsaWQgc3RhcnRpbmcuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdTdGFydFBvcykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvdGcgPSB0YWdzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgIT09IG90Zy50YWdOYW1lKSB7XG4gICAgICAgICAgICAgIGxldCBvcGVuUG9zID0gZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIG90Zy50YWdTdGFydFBvcyk7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBjbG9zaW5nIHRhZyAnXCIrb3RnLnRhZ05hbWUrXCInIChvcGVuZWQgaW4gbGluZSBcIitvcGVuUG9zLmxpbmUrXCIsIGNvbCBcIitvcGVuUG9zLmNvbCtcIikgaW5zdGVhZCBvZiBjbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicuXCIsXG4gICAgICAgICAgICAgICAgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIHRhZ1N0YXJ0UG9zKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSB0YWdzLCB3ZSByZWFjaGVkIHRoZSByb290IGxldmVsLlxuICAgICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgcmVhY2hlZFJvb3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGlzVmFsaWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vdGhlIHJlc3VsdCBmcm9tIHRoZSBuZXN0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGVycm9yIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL2luIG9yZGVyIHRvIGdldCB0aGUgJ3RydWUnIGVycm9yIGxpbmUsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlIGJlZ2lucyAoaSAtIGF0dHJTdHIubGVuZ3RoKSBhbmQgdGhlbiBhZGQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL3RoaXMgZ2l2ZXMgdXMgdGhlIGFic29sdXRlIGluZGV4IGluIHRoZSBlbnRpcmUgeG1sLCB3aGljaCB3ZSBjYW4gdXNlIHRvIGZpbmQgdGhlIGxpbmUgYXQgbGFzdFxuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KGlzVmFsaWQuZXJyLmNvZGUsIGlzVmFsaWQuZXJyLm1zZywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkgLSBhdHRyU3RyLmxlbmd0aCArIGlzVmFsaWQuZXJyLmxpbmUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2lmIHRoZSByb290IGxldmVsIGhhcyBiZWVuIHJlYWNoZWQgYmVmb3JlIC4uLlxuICAgICAgICAgIGlmIChyZWFjaGVkUm9vdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgJ011bHRpcGxlIHBvc3NpYmxlIHJvb3Qgbm9kZXMgZm91bmQuJywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICB9IGVsc2UgaWYob3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpe1xuICAgICAgICAgICAgLy9kb24ndCBwdXNoIGludG8gc3RhY2tcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFncy5wdXNoKHt0YWdOYW1lLCB0YWdTdGFydFBvc30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWdGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NraXAgdGFnIHRleHQgdmFsdWVcbiAgICAgICAgLy9JdCBtYXkgaW5jbHVkZSBjb21tZW50cyBhbmQgQ0RBVEEgdmFsdWVcbiAgICAgICAgZm9yIChpKys7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgICAgICAgaWYgKHhtbERhdGFbaSArIDFdID09PSAnIScpIHtcbiAgICAgICAgICAgICAgLy9jb21tZW50IG9yIENBREFUQVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGkgPSByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpKzFdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgaSA9IHJlYWRQSSh4bWxEYXRhLCArK2kpO1xuICAgICAgICAgICAgICBpZiAoaS5lcnIpIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICcmJykge1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJBbXAgPSB2YWxpZGF0ZUFtcGVyc2FuZCh4bWxEYXRhLCBpKTtcbiAgICAgICAgICAgIGlmIChhZnRlckFtcCA9PSAtMSlcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQ2hhcicsIFwiY2hhciAnJicgaXMgbm90IGV4cGVjdGVkLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgICAgaSA9IGFmdGVyQW1wO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgaWYgKHJlYWNoZWRSb290ID09PSB0cnVlICYmICFpc1doaXRlU3BhY2UoeG1sRGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgXCJFeHRyYSB0ZXh0IGF0IHRoZSBlbmRcIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy9lbmQgb2YgcmVhZGluZyB0YWcgdGV4dCB2YWx1ZVxuICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICggaXNXaGl0ZVNwYWNlKHhtbERhdGFbaV0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQ2hhcicsIFwiY2hhciAnXCIreG1sRGF0YVtpXStcIicgaXMgbm90IGV4cGVjdGVkLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGFnRm91bmQpIHtcbiAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCAnU3RhcnQgdGFnIGV4cGVjdGVkLicsIDEpO1xuICB9ZWxzZSBpZiAodGFncy5sZW5ndGggPT0gMSkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJVbmNsb3NlZCB0YWcgJ1wiK3RhZ3NbMF0udGFnTmFtZStcIicuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdzWzBdLnRhZ1N0YXJ0UG9zKSk7XG4gIH1lbHNlIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsIFwiSW52YWxpZCAnXCIrXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGFncy5tYXAodCA9PiB0LnRhZ05hbWUpLCBudWxsLCA0KS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKStcbiAgICAgICAgICBcIicgZm91bmQuXCIsIHtsaW5lOiAxLCBjb2w6IDF9KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoYXIpe1xuICByZXR1cm4gY2hhciA9PT0gJyAnIHx8IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICdcXG4nICB8fCBjaGFyID09PSAnXFxyJztcbn1cbi8qKlxuICogUmVhZCBQcm9jZXNzaW5nIGluc3N0cnVjdGlvbnMgYW5kIHNraXBcbiAqIEBwYXJhbSB7Kn0geG1sRGF0YVxuICogQHBhcmFtIHsqfSBpXG4gKi9cbmZ1bmN0aW9uIHJlYWRQSSh4bWxEYXRhLCBpKSB7XG4gIGNvbnN0IHN0YXJ0ID0gaTtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT0gJz8nIHx8IHhtbERhdGFbaV0gPT0gJyAnKSB7XG4gICAgICAvL3RhZ25hbWVcbiAgICAgIGNvbnN0IHRhZ25hbWUgPSB4bWxEYXRhLnN1YnN0cihzdGFydCwgaSAtIHN0YXJ0KTtcbiAgICAgIGlmIChpID4gNSAmJiB0YWduYW1lID09PSAneG1sJykge1xuICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCAnWE1MIGRlY2xhcmF0aW9uIGFsbG93ZWQgb25seSBhdCB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LicsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT0gJz8nICYmIHhtbERhdGFbaSArIDFdID09ICc+Jykge1xuICAgICAgICAvL2NoZWNrIGlmIHZhbGlkIGF0dHJpYnV0IHN0cmluZ1xuICAgICAgICBpKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpIHtcbiAgaWYgKHhtbERhdGEubGVuZ3RoID4gaSArIDUgJiYgeG1sRGF0YVtpICsgMV0gPT09ICctJyAmJiB4bWxEYXRhW2kgKyAyXSA9PT0gJy0nKSB7XG4gICAgLy9jb21tZW50XG4gICAgZm9yIChpICs9IDM7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJy0nICYmIHhtbERhdGFbaSArIDFdID09PSAnLScgJiYgeG1sRGF0YVtpICsgMl0gPT09ICc+Jykge1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB4bWxEYXRhLmxlbmd0aCA+IGkgKyA4ICYmXG4gICAgeG1sRGF0YVtpICsgMV0gPT09ICdEJyAmJlxuICAgIHhtbERhdGFbaSArIDJdID09PSAnTycgJiZcbiAgICB4bWxEYXRhW2kgKyAzXSA9PT0gJ0MnICYmXG4gICAgeG1sRGF0YVtpICsgNF0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSArIDVdID09PSAnWScgJiZcbiAgICB4bWxEYXRhW2kgKyA2XSA9PT0gJ1AnICYmXG4gICAgeG1sRGF0YVtpICsgN10gPT09ICdFJ1xuICApIHtcbiAgICBsZXQgYW5nbGVCcmFja2V0c0NvdW50ID0gMTtcbiAgICBmb3IgKGkgKz0gODsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+Jykge1xuICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgaWYgKGFuZ2xlQnJhY2tldHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHhtbERhdGEubGVuZ3RoID4gaSArIDkgJiZcbiAgICB4bWxEYXRhW2kgKyAxXSA9PT0gJ1snICYmXG4gICAgeG1sRGF0YVtpICsgMl0gPT09ICdDJyAmJlxuICAgIHhtbERhdGFbaSArIDNdID09PSAnRCcgJiZcbiAgICB4bWxEYXRhW2kgKyA0XSA9PT0gJ0EnICYmXG4gICAgeG1sRGF0YVtpICsgNV0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSArIDZdID09PSAnQScgJiZcbiAgICB4bWxEYXRhW2kgKyA3XSA9PT0gJ1snXG4gICkge1xuICAgIGZvciAoaSArPSA4OyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICddJyAmJiB4bWxEYXRhW2kgKyAxXSA9PT0gJ10nICYmIHhtbERhdGFbaSArIDJdID09PSAnPicpIHtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTtcbn1cblxuY29uc3QgZG91YmxlUXVvdGUgPSAnXCInO1xuY29uc3Qgc2luZ2xlUXVvdGUgPSBcIidcIjtcblxuLyoqXG4gKiBLZWVwIHJlYWRpbmcgeG1sRGF0YSB1bnRpbCAnPCcgaXMgZm91bmQgb3V0c2lkZSB0aGUgYXR0cmlidXRlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHhtbERhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVTdHIoeG1sRGF0YSwgaSkge1xuICBsZXQgYXR0clN0ciA9ICcnO1xuICBsZXQgc3RhcnRDaGFyID0gJyc7XG4gIGxldCB0YWdDbG9zZWQgPSBmYWxzZTtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT09IGRvdWJsZVF1b3RlIHx8IHhtbERhdGFbaV0gPT09IHNpbmdsZVF1b3RlKSB7XG4gICAgICBpZiAoc3RhcnRDaGFyID09PSAnJykge1xuICAgICAgICBzdGFydENoYXIgPSB4bWxEYXRhW2ldO1xuICAgICAgfSBlbHNlIGlmIChzdGFydENoYXIgIT09IHhtbERhdGFbaV0pIHtcbiAgICAgICAgLy9pZiB2YXVlIGlzIGVuY2xvc2VkIHdpdGggZG91YmxlIHF1b3RlIHRoZW4gc2luZ2xlIHF1b3RlcyBhcmUgYWxsb3dlZCBpbnNpZGUgdGhlIHZhbHVlIGFuZCB2aWNlIHZlcnNhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydENoYXIgPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+Jykge1xuICAgICAgaWYgKHN0YXJ0Q2hhciA9PT0gJycpIHtcbiAgICAgICAgdGFnQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dHJTdHIgKz0geG1sRGF0YVtpXTtcbiAgfVxuICBpZiAoc3RhcnRDaGFyICE9PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGF0dHJTdHIsXG4gICAgaW5kZXg6IGksXG4gICAgdGFnQ2xvc2VkOiB0YWdDbG9zZWRcbiAgfTtcbn1cblxuLyoqXG4gKiBTZWxlY3QgYWxsIHRoZSBhdHRyaWJ1dGVzIHdoZXRoZXIgdmFsaWQgb3IgaW52YWxpZC5cbiAqL1xuY29uc3QgdmFsaWRBdHRyU3RyUmVneHAgPSBuZXcgUmVnRXhwKCcoXFxcXHMqKShbXlxcXFxzPV0rKShcXFxccyo9KT8oXFxcXHMqKFtcXCdcIl0pKChbXFxcXHNcXFxcU10pKj8pXFxcXDUpPycsICdnJyk7XG5cbi8vYXR0ciwgPVwic2RcIiwgYT1cImFtaXQnc1wiLCBhPVwic2RcImI9XCJzYWZcIiwgYWIgIGNkPVwiXCJcblxuZnVuY3Rpb24gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucykge1xuICAvL2NvbnNvbGUubG9nKFwic3RhcnQ6XCIrYXR0clN0citcIjplbmRcIik7XG5cbiAgLy9pZihhdHRyU3RyLnRyaW0oKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlOyAvL2VtcHR5IHN0cmluZ1xuXG4gIGNvbnN0IG1hdGNoZXMgPSB1dGlsLmdldEFsbE1hdGNoZXMoYXR0clN0ciwgdmFsaWRBdHRyU3RyUmVneHApO1xuICBjb25zdCBhdHRyTmFtZXMgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWF0Y2hlc1tpXVsxXS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vbm9zcGFjZSBiZWZvcmUgYXR0cmlidXRlIG5hbWU6IGE9XCJzZFwiYj1cInNhZlwiXG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK21hdGNoZXNbaV1bMl0rXCInIGhhcyBubyBzcGFjZSBpbiBzdGFydGluZy5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpXG4gICAgfSBlbHNlIGlmIChtYXRjaGVzW2ldWzNdICE9PSB1bmRlZmluZWQgJiYgbWF0Y2hlc1tpXVs0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK21hdGNoZXNbaV1bMl0rXCInIGlzIHdpdGhvdXQgdmFsdWUuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXNbaV1bM10gPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5hbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAvL2luZGVwZW5kZW50IGF0dHJpYnV0ZTogYWJcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcImJvb2xlYW4gYXR0cmlidXRlICdcIittYXRjaGVzW2ldWzJdK1wiJyBpcyBub3QgYWxsb3dlZC5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH1cbiAgICAvKiBlbHNlIGlmKG1hdGNoZXNbaV1bNl0gPT09IHVuZGVmaW5lZCl7Ly9hdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZTogYWI9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycjogeyBjb2RlOlwiSW52YWxpZEF0dHJcIixtc2c6XCJhdHRyaWJ1dGUgXCIgKyBtYXRjaGVzW2ldWzJdICsgXCIgaGFzIG5vIHZhbHVlIGFzc2lnbmVkLlwifX07XG4gICAgICAgICAgICAgICAgfSAqL1xuICAgIGNvbnN0IGF0dHJOYW1lID0gbWF0Y2hlc1tpXVsyXTtcbiAgICBpZiAoIXZhbGlkYXRlQXR0ck5hbWUoYXR0ck5hbWUpKSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK2F0dHJOYW1lK1wiJyBpcyBhbiBpbnZhbGlkIG5hbWUuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9XG4gICAgaWYgKCFhdHRyTmFtZXMuaGFzT3duUHJvcGVydHkoYXR0ck5hbWUpKSB7XG4gICAgICAvL2NoZWNrIGZvciBkdXBsaWNhdGUgYXR0cmlidXRlLlxuICAgICAgYXR0ck5hbWVzW2F0dHJOYW1lXSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrYXR0ck5hbWUrXCInIGlzIHJlcGVhdGVkLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyQW1wZXJzYW5kKHhtbERhdGEsIGkpIHtcbiAgbGV0IHJlID0gL1xcZC87XG4gIGlmICh4bWxEYXRhW2ldID09PSAneCcpIHtcbiAgICBpKys7XG4gICAgcmUgPSAvW1xcZGEtZkEtRl0vO1xuICB9XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4bWxEYXRhW2ldID09PSAnOycpXG4gICAgICByZXR1cm4gaTtcbiAgICBpZiAoIXhtbERhdGFbaV0ubWF0Y2gocmUpKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFtcGVyc2FuZCh4bWxEYXRhLCBpKSB7XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI2R0LWNoYXJyZWZcbiAgaSsrO1xuICBpZiAoeG1sRGF0YVtpXSA9PT0gJzsnKVxuICAgIHJldHVybiAtMTtcbiAgaWYgKHhtbERhdGFbaV0gPT09ICcjJykge1xuICAgIGkrKztcbiAgICByZXR1cm4gdmFsaWRhdGVOdW1iZXJBbXBlcnNhbmQoeG1sRGF0YSwgaSk7XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrLCBjb3VudCsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0ubWF0Y2goL1xcdy8pICYmIGNvdW50IDwgMjApXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzsnKVxuICAgICAgYnJlYWs7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBnZXRFcnJvck9iamVjdChjb2RlLCBtZXNzYWdlLCBsaW5lTnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgZXJyOiB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgbXNnOiBtZXNzYWdlLFxuICAgICAgbGluZTogbGluZU51bWJlci5saW5lIHx8IGxpbmVOdW1iZXIsXG4gICAgICBjb2w6IGxpbmVOdW1iZXIuY29sLFxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXR0ck5hbWUoYXR0ck5hbWUpIHtcbiAgcmV0dXJuIHV0aWwuaXNOYW1lKGF0dHJOYW1lKTtcbn1cblxuLy8gY29uc3Qgc3RhcnRzV2l0aFhNTCA9IC9eeG1sL2k7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFnTmFtZSh0YWduYW1lKSB7XG4gIHJldHVybiB1dGlsLmlzTmFtZSh0YWduYW1lKSAvKiAmJiAhdGFnbmFtZS5tYXRjaChzdGFydHNXaXRoWE1MKSAqLztcbn1cblxuLy90aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGxpbmUgbnVtYmVyIGZvciB0aGUgY2hhcmFjdGVyIGF0IHRoZSBnaXZlbiBpbmRleFxuZnVuY3Rpb24gZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGluZGV4KSB7XG4gIGNvbnN0IGxpbmVzID0geG1sRGF0YS5zdWJzdHJpbmcoMCwgaW5kZXgpLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHJldHVybiB7XG4gICAgbGluZTogbGluZXMubGVuZ3RoLFxuXG4gICAgLy8gY29sdW1uIG51bWJlciBpcyBsYXN0IGxpbmUncyBsZW5ndGggKyAxLCBiZWNhdXNlIGNvbHVtbiBudW1iZXJpbmcgc3RhcnRzIGF0IDE6XG4gICAgY29sOiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggKyAxXG4gIH07XG59XG5cbi8vdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIG1hdGNoIHdpdGhpbiBhdHRyU3RyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaCkge1xuICByZXR1cm4gbWF0Y2guc3RhcnRJbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbn1cbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImRlZmF1bHRPcHRpb25zIiwiYWxsb3dCb29sZWFuQXR0cmlidXRlcyIsInVucGFpcmVkVGFncyIsImV4cG9ydHMiLCJ2YWxpZGF0ZSIsInhtbERhdGEiLCJvcHRpb25zIiwiT2JqZWN0IiwiYXNzaWduIiwidGFncyIsInRhZ0ZvdW5kIiwicmVhY2hlZFJvb3QiLCJzdWJzdHIiLCJpIiwibGVuZ3RoIiwicmVhZFBJIiwiZXJyIiwidGFnU3RhcnRQb3MiLCJyZWFkQ29tbWVudEFuZENEQVRBIiwiY2xvc2luZ1RhZyIsInRhZ05hbWUiLCJ0cmltIiwic3Vic3RyaW5nIiwidmFsaWRhdGVUYWdOYW1lIiwibXNnIiwiZ2V0RXJyb3JPYmplY3QiLCJnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24iLCJyZXN1bHQiLCJyZWFkQXR0cmlidXRlU3RyIiwiYXR0clN0ciIsInZhbHVlIiwiaW5kZXgiLCJhdHRyU3RyU3RhcnQiLCJpc1ZhbGlkIiwidmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmciLCJjb2RlIiwibGluZSIsInRhZ0Nsb3NlZCIsIm90ZyIsInBvcCIsIm9wZW5Qb3MiLCJjb2wiLCJpbmRleE9mIiwicHVzaCIsImFmdGVyQW1wIiwidmFsaWRhdGVBbXBlcnNhbmQiLCJpc1doaXRlU3BhY2UiLCJKU09OIiwic3RyaW5naWZ5IiwibWFwIiwidCIsInJlcGxhY2UiLCJjaGFyIiwic3RhcnQiLCJ0YWduYW1lIiwiYW5nbGVCcmFja2V0c0NvdW50IiwiZG91YmxlUXVvdGUiLCJzaW5nbGVRdW90ZSIsInN0YXJ0Q2hhciIsInZhbGlkQXR0clN0clJlZ3hwIiwiUmVnRXhwIiwibWF0Y2hlcyIsImdldEFsbE1hdGNoZXMiLCJhdHRyTmFtZXMiLCJnZXRQb3NpdGlvbkZyb21NYXRjaCIsInVuZGVmaW5lZCIsImF0dHJOYW1lIiwidmFsaWRhdGVBdHRyTmFtZSIsImhhc093blByb3BlcnR5IiwidmFsaWRhdGVOdW1iZXJBbXBlcnNhbmQiLCJyZSIsIm1hdGNoIiwiY291bnQiLCJtZXNzYWdlIiwibGluZU51bWJlciIsImlzTmFtZSIsImxpbmVzIiwic3BsaXQiLCJzdGFydEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/validator.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = __webpack_require__(/*! ./orderedJs2Xml */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\");\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attributesGroupName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataPropName: false,\n    format: false,\n    indentBy: \"  \",\n    suppressEmptyNode: false,\n    suppressUnpairedNode: true,\n    suppressBooleanAttributes: true,\n    tagValueProcessor: function(key, a) {\n        return a;\n    },\n    attributeValueProcessor: function(attrName, a) {\n        return a;\n    },\n    preserveOrder: false,\n    commentPropName: false,\n    unpairedTags: [],\n    entities: [\n        {\n            regex: new RegExp(\"&\", \"g\"),\n            val: \"&amp;\"\n        },\n        {\n            regex: new RegExp(\">\", \"g\"),\n            val: \"&gt;\"\n        },\n        {\n            regex: new RegExp(\"<\", \"g\"),\n            val: \"&lt;\"\n        },\n        {\n            regex: new RegExp(\"'\", \"g\"),\n            val: \"&apos;\"\n        },\n        {\n            regex: new RegExp('\"', \"g\"),\n            val: \"&quot;\"\n        }\n    ],\n    processEntities: true,\n    stopNodes: [],\n    // transformTagName: false,\n    // transformAttributeName: false,\n    oneListGroup: false\n};\nfunction Builder(options) {\n    this.options = Object.assign({}, defaultOptions, options);\n    if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n        this.isAttribute = function() {\n            return false;\n        };\n    } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n    }\n    this.processTextOrObjNode = processTextOrObjNode;\n    if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n    } else {\n        this.indentate = function() {\n            return \"\";\n        };\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n    }\n}\nBuilder.prototype.build = function(jObj) {\n    if (this.options.preserveOrder) {\n        return buildFromOrderedJs(jObj, this.options);\n    } else {\n        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {\n            jObj = {\n                [this.options.arrayNodeName]: jObj\n            };\n        }\n        return this.j2x(jObj, 0).val;\n    }\n};\nBuilder.prototype.j2x = function(jObj, level) {\n    let attrStr = \"\";\n    let val = \"\";\n    for(let key in jObj){\n        if (typeof jObj[key] === \"undefined\") {\n        // supress undefined node\n        } else if (jObj[key] === null) {\n            if (key[0] === \"?\") val += this.indentate(level) + \"<\" + key + \"?\" + this.tagEndChar;\n            else val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n        // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (jObj[key] instanceof Date) {\n            val += this.buildTextValNode(jObj[key], key, \"\", level);\n        } else if (typeof jObj[key] !== \"object\") {\n            //premitive type\n            const attr = this.isAttribute(key);\n            if (attr) {\n                attrStr += this.buildAttrPairStr(attr, \"\" + jObj[key]);\n            } else {\n                //tag value\n                if (key === this.options.textNodeName) {\n                    let newval = this.options.tagValueProcessor(key, \"\" + jObj[key]);\n                    val += this.replaceEntitiesValue(newval);\n                } else {\n                    val += this.buildTextValNode(jObj[key], key, \"\", level);\n                }\n            }\n        } else if (Array.isArray(jObj[key])) {\n            //repeated nodes\n            const arrLen = jObj[key].length;\n            let listTagVal = \"\";\n            for(let j = 0; j < arrLen; j++){\n                const item = jObj[key][j];\n                if (typeof item === \"undefined\") {\n                // supress undefined node\n                } else if (item === null) {\n                    if (key[0] === \"?\") val += this.indentate(level) + \"<\" + key + \"?\" + this.tagEndChar;\n                    else val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n                // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n                } else if (typeof item === \"object\") {\n                    if (this.options.oneListGroup) {\n                        listTagVal += this.j2x(item, level + 1).val;\n                    } else {\n                        listTagVal += this.processTextOrObjNode(item, key, level);\n                    }\n                } else {\n                    listTagVal += this.buildTextValNode(item, key, \"\", level);\n                }\n            }\n            if (this.options.oneListGroup) {\n                listTagVal = this.buildObjectNode(listTagVal, key, \"\", level);\n            }\n            val += listTagVal;\n        } else {\n            //nested node\n            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n                const Ks = Object.keys(jObj[key]);\n                const L = Ks.length;\n                for(let j = 0; j < L; j++){\n                    attrStr += this.buildAttrPairStr(Ks[j], \"\" + jObj[key][Ks[j]]);\n                }\n            } else {\n                val += this.processTextOrObjNode(jObj[key], key, level);\n            }\n        }\n    }\n    return {\n        attrStr: attrStr,\n        val: val\n    };\n};\nBuilder.prototype.buildAttrPairStr = function(attrName, val) {\n    val = this.options.attributeValueProcessor(attrName, \"\" + val);\n    val = this.replaceEntitiesValue(val);\n    if (this.options.suppressBooleanAttributes && val === \"true\") {\n        return \" \" + attrName;\n    } else return \" \" + attrName + '=\"' + val + '\"';\n};\nfunction processTextOrObjNode(object, key, level) {\n    const result = this.j2x(object, level + 1);\n    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n    } else {\n        return this.buildObjectNode(result.val, key, result.attrStr, level);\n    }\n}\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n    if (val === \"\") {\n        if (key[0] === \"?\") return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n        else {\n            return this.indentate(level) + \"<\" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        }\n    } else {\n        let tagEndExp = \"</\" + key + this.tagEndChar;\n        let piClosingChar = \"\";\n        if (key[0] === \"?\") {\n            piClosingChar = \"?\";\n            tagEndExp = \"\";\n        }\n        if (attrStr && val.indexOf(\"<\") === -1) {\n            return this.indentate(level) + \"<\" + key + attrStr + piClosingChar + \">\" + val + tagEndExp;\n        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n            return this.indentate(level) + `<!--${val}-->` + this.newLine;\n        } else {\n            return this.indentate(level) + \"<\" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;\n        }\n    }\n};\nBuilder.prototype.closeTag = function(key) {\n    let closeTag = \"\";\n    if (this.options.unpairedTags.indexOf(key) !== -1) {\n        if (!this.options.suppressUnpairedNode) closeTag = \"/\";\n    } else if (this.options.suppressEmptyNode) {\n        closeTag = \"/\";\n    } else {\n        closeTag = `></${key}`;\n    }\n    return closeTag;\n};\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        if (key[0] === \"?\") return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n        else {\n            return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n        // return this.buildTagStr(level,key, attrStr);\n        }\n    }\n}\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n        return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    } else if (key[0] === \"?\") {\n        return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n    } else {\n        let textValue = this.options.tagValueProcessor(key, val);\n        textValue = this.replaceEntitiesValue(textValue);\n        if (textValue === \"\") {\n            return this.indentate(level) + \"<\" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        } else {\n            return this.indentate(level) + \"<\" + key + attrStr + \">\" + textValue + \"</\" + key + this.tagEndChar;\n        }\n    }\n};\nBuilder.prototype.replaceEntitiesValue = function(textValue) {\n    if (textValue && textValue.length > 0 && this.options.processEntities) {\n        for(let i = 0; i < this.options.entities.length; i++){\n            const entity = this.options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n};\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\nfunction isAttribute(name /*, options*/ ) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\nmodule.exports = Builder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL2pzb24yeG1sLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE1BQU1BLHFCQUFxQkMsbUJBQU9BLENBQUM7QUFFbkMsTUFBTUMsaUJBQWlCO0lBQ3JCQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsY0FBYztJQUNkQyxrQkFBa0I7SUFDbEJDLGVBQWU7SUFDZkMsUUFBUTtJQUNSQyxVQUFVO0lBQ1ZDLG1CQUFtQjtJQUNuQkMsc0JBQXNCO0lBQ3RCQywyQkFBMkI7SUFDM0JDLG1CQUFtQixTQUFTQyxHQUFHLEVBQUVDLENBQUM7UUFDaEMsT0FBT0E7SUFDVDtJQUNBQyx5QkFBeUIsU0FBU0MsUUFBUSxFQUFFRixDQUFDO1FBQzNDLE9BQU9BO0lBQ1Q7SUFDQUcsZUFBZTtJQUNmQyxpQkFBaUI7SUFDakJDLGNBQWMsRUFBRTtJQUNoQkMsVUFBVTtRQUNSO1lBQUVDLE9BQU8sSUFBSUMsT0FBTyxLQUFLO1lBQU1DLEtBQUs7UUFBUTtRQUM1QztZQUFFRixPQUFPLElBQUlDLE9BQU8sS0FBSztZQUFNQyxLQUFLO1FBQU87UUFDM0M7WUFBRUYsT0FBTyxJQUFJQyxPQUFPLEtBQUs7WUFBTUMsS0FBSztRQUFPO1FBQzNDO1lBQUVGLE9BQU8sSUFBSUMsT0FBTyxLQUFNO1lBQU1DLEtBQUs7UUFBUztRQUM5QztZQUFFRixPQUFPLElBQUlDLE9BQU8sS0FBTTtZQUFNQyxLQUFLO1FBQVM7S0FDL0M7SUFDREMsaUJBQWlCO0lBQ2pCQyxXQUFXLEVBQUU7SUFDYiwyQkFBMkI7SUFDM0IsaUNBQWlDO0lBQ2pDQyxjQUFjO0FBQ2hCO0FBRUEsU0FBU0MsUUFBUUMsT0FBTztJQUN0QixJQUFJLENBQUNBLE9BQU8sR0FBR0MsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRzdCLGdC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QUVBNkMsT0FBT0MsT0FBTyxHQUFHbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL2pzb24yeG1sLmpzP2EyMmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy9wYXJzZSBFbXB0eSBOb2RlIGFzIHNlbGYgY2xvc2luZyBub2RlXG5jb25zdCBidWlsZEZyb21PcmRlcmVkSnMgPSByZXF1aXJlKCcuL29yZGVyZWRKczJYbWwnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGF0dHJpYnV0ZU5hbWVQcmVmaXg6ICdAXycsXG4gIGF0dHJpYnV0ZXNHcm91cE5hbWU6IGZhbHNlLFxuICB0ZXh0Tm9kZU5hbWU6ICcjdGV4dCcsXG4gIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWUsXG4gIGNkYXRhUHJvcE5hbWU6IGZhbHNlLFxuICBmb3JtYXQ6IGZhbHNlLFxuICBpbmRlbnRCeTogJyAgJyxcbiAgc3VwcHJlc3NFbXB0eU5vZGU6IGZhbHNlLFxuICBzdXBwcmVzc1VucGFpcmVkTm9kZTogdHJ1ZSxcbiAgc3VwcHJlc3NCb29sZWFuQXR0cmlidXRlczogdHJ1ZSxcbiAgdGFnVmFsdWVQcm9jZXNzb3I6IGZ1bmN0aW9uKGtleSwgYSkge1xuICAgIHJldHVybiBhO1xuICB9LFxuICBhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcjogZnVuY3Rpb24oYXR0ck5hbWUsIGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgcHJlc2VydmVPcmRlcjogZmFsc2UsXG4gIGNvbW1lbnRQcm9wTmFtZTogZmFsc2UsXG4gIHVucGFpcmVkVGFnczogW10sXG4gIGVudGl0aWVzOiBbXG4gICAgeyByZWdleDogbmV3IFJlZ0V4cChcIiZcIiwgXCJnXCIpLCB2YWw6IFwiJmFtcDtcIiB9LC8vaXQgbXVzdCBiZSBvbiB0b3BcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiPlwiLCBcImdcIiksIHZhbDogXCImZ3Q7XCIgfSxcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiPFwiLCBcImdcIiksIHZhbDogXCImbHQ7XCIgfSxcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiXFwnXCIsIFwiZ1wiKSwgdmFsOiBcIiZhcG9zO1wiIH0sXG4gICAgeyByZWdleDogbmV3IFJlZ0V4cChcIlxcXCJcIiwgXCJnXCIpLCB2YWw6IFwiJnF1b3Q7XCIgfVxuICBdLFxuICBwcm9jZXNzRW50aXRpZXM6IHRydWUsXG4gIHN0b3BOb2RlczogW10sXG4gIC8vIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAvLyB0cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lOiBmYWxzZSxcbiAgb25lTGlzdEdyb3VwOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gQnVpbGRlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzIHx8IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzR3JvdXBOYW1lKSB7XG4gICAgdGhpcy5pc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uKC8qYSovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJQcmVmaXhMZW4gPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeC5sZW5ndGg7XG4gICAgdGhpcy5pc0F0dHJpYnV0ZSA9IGlzQXR0cmlidXRlO1xuICB9XG5cbiAgdGhpcy5wcm9jZXNzVGV4dE9yT2JqTm9kZSA9IHByb2Nlc3NUZXh0T3JPYmpOb2RlXG5cbiAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQpIHtcbiAgICB0aGlzLmluZGVudGF0ZSA9IGluZGVudGF0ZTtcbiAgICB0aGlzLnRhZ0VuZENoYXIgPSAnPlxcbic7XG4gICAgdGhpcy5uZXdMaW5lID0gJ1xcbic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbmRlbnRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHRoaXMudGFnRW5kQ2hhciA9ICc+JztcbiAgICB0aGlzLm5ld0xpbmUgPSAnJztcbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGpPYmopIHtcbiAgaWYodGhpcy5vcHRpb25zLnByZXNlcnZlT3JkZXIpe1xuICAgIHJldHVybiBidWlsZEZyb21PcmRlcmVkSnMoak9iaiwgdGhpcy5vcHRpb25zKTtcbiAgfWVsc2Uge1xuICAgIGlmKEFycmF5LmlzQXJyYXkoak9iaikgJiYgdGhpcy5vcHRpb25zLmFycmF5Tm9kZU5hbWUgJiYgdGhpcy5vcHRpb25zLmFycmF5Tm9kZU5hbWUubGVuZ3RoID4gMSl7XG4gICAgICBqT2JqID0ge1xuICAgICAgICBbdGhpcy5vcHRpb25zLmFycmF5Tm9kZU5hbWVdIDogak9ialxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5qMngoak9iaiwgMCkudmFsO1xuICB9XG59O1xuXG5CdWlsZGVyLnByb3RvdHlwZS5qMnggPSBmdW5jdGlvbihqT2JqLCBsZXZlbCkge1xuICBsZXQgYXR0clN0ciA9ICcnO1xuICBsZXQgdmFsID0gJyc7XG4gIGZvciAobGV0IGtleSBpbiBqT2JqKSB7XG4gICAgaWYgKHR5cGVvZiBqT2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBzdXByZXNzIHVuZGVmaW5lZCBub2RlXG4gICAgfSBlbHNlIGlmIChqT2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgIGlmKGtleVswXSA9PT0gXCI/XCIpIHZhbCArPSB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyAnPycgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgICBlbHNlIHZhbCArPSB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyAnLycgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgICAvLyB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJy8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIH0gZWxzZSBpZiAoak9ialtrZXldIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgdmFsICs9IHRoaXMuYnVpbGRUZXh0VmFsTm9kZShqT2JqW2tleV0sIGtleSwgJycsIGxldmVsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBqT2JqW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAvL3ByZW1pdGl2ZSB0eXBlXG4gICAgICBjb25zdCBhdHRyID0gdGhpcy5pc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgaWYgKGF0dHIpIHtcbiAgICAgICAgYXR0clN0ciArPSB0aGlzLmJ1aWxkQXR0clBhaXJTdHIoYXR0ciwgJycgKyBqT2JqW2tleV0pO1xuICAgICAgfWVsc2Uge1xuICAgICAgICAvL3RhZyB2YWx1ZVxuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lKSB7XG4gICAgICAgICAgbGV0IG5ld3ZhbCA9IHRoaXMub3B0aW9ucy50YWdWYWx1ZVByb2Nlc3NvcihrZXksICcnICsgak9ialtrZXldKTtcbiAgICAgICAgICB2YWwgKz0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZShuZXd2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCArPSB0aGlzLmJ1aWxkVGV4dFZhbE5vZGUoak9ialtrZXldLCBrZXksICcnLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoak9ialtrZXldKSkge1xuICAgICAgLy9yZXBlYXRlZCBub2Rlc1xuICAgICAgY29uc3QgYXJyTGVuID0gak9ialtrZXldLmxlbmd0aDtcbiAgICAgIGxldCBsaXN0VGFnVmFsID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyTGVuOyBqKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGpPYmpba2V5XVtqXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIHN1cHJlc3MgdW5kZWZpbmVkIG5vZGVcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgaWYoa2V5WzBdID09PSBcIj9cIikgdmFsICs9IHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArICc/JyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgICAgICBlbHNlIHZhbCArPSB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyAnLycgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgICAgICAgLy8gdmFsICs9IHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZih0aGlzLm9wdGlvbnMub25lTGlzdEdyb3VwICl7XG4gICAgICAgICAgICBsaXN0VGFnVmFsICs9IHRoaXMuajJ4KGl0ZW0sIGxldmVsICsgMSkudmFsO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgbGlzdFRhZ1ZhbCArPSB0aGlzLnByb2Nlc3NUZXh0T3JPYmpOb2RlKGl0ZW0sIGtleSwgbGV2ZWwpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RUYWdWYWwgKz0gdGhpcy5idWlsZFRleHRWYWxOb2RlKGl0ZW0sIGtleSwgJycsIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYodGhpcy5vcHRpb25zLm9uZUxpc3RHcm91cCl7XG4gICAgICAgIGxpc3RUYWdWYWwgPSB0aGlzLmJ1aWxkT2JqZWN0Tm9kZShsaXN0VGFnVmFsLCBrZXksICcnLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICB2YWwgKz0gbGlzdFRhZ1ZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9uZXN0ZWQgbm9kZVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzR3JvdXBOYW1lICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWUpIHtcbiAgICAgICAgY29uc3QgS3MgPSBPYmplY3Qua2V5cyhqT2JqW2tleV0pO1xuICAgICAgICBjb25zdCBMID0gS3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IEw7IGorKykge1xuICAgICAgICAgIGF0dHJTdHIgKz0gdGhpcy5idWlsZEF0dHJQYWlyU3RyKEtzW2pdLCAnJyArIGpPYmpba2V5XVtLc1tqXV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgKz0gdGhpcy5wcm9jZXNzVGV4dE9yT2JqTm9kZShqT2JqW2tleV0sIGtleSwgbGV2ZWwpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7YXR0clN0cjogYXR0clN0ciwgdmFsOiB2YWx9O1xufTtcblxuQnVpbGRlci5wcm90b3R5cGUuYnVpbGRBdHRyUGFpclN0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lLCB2YWwpe1xuICB2YWwgPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IoYXR0ck5hbWUsICcnICsgdmFsKTtcbiAgdmFsID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSh2YWwpO1xuICBpZiAodGhpcy5vcHRpb25zLnN1cHByZXNzQm9vbGVhbkF0dHJpYnV0ZXMgJiYgdmFsID09PSBcInRydWVcIikge1xuICAgIHJldHVybiAnICcgKyBhdHRyTmFtZTtcbiAgfSBlbHNlIHJldHVybiAnICcgKyBhdHRyTmFtZSArICc9XCInICsgdmFsICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1RleHRPck9iak5vZGUgKG9iamVjdCwga2V5LCBsZXZlbCkge1xuICBjb25zdCByZXN1bHQgPSB0aGlzLmoyeChvYmplY3QsIGxldmVsICsgMSk7XG4gIGlmIChvYmplY3RbdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZV0gIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkVGV4dFZhbE5vZGUob2JqZWN0W3RoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWVdLCBrZXksIHJlc3VsdC5hdHRyU3RyLCBsZXZlbCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRPYmplY3ROb2RlKHJlc3VsdC52YWwsIGtleSwgcmVzdWx0LmF0dHJTdHIsIGxldmVsKTtcbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5idWlsZE9iamVjdE5vZGUgPSBmdW5jdGlvbih2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYodmFsID09PSBcIlwiKXtcbiAgICBpZihrZXlbMF0gPT09IFwiP1wiKSByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyBhdHRyU3RyICsgdGhpcy5jbG9zZVRhZyhrZXkpICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIH1cbiAgfWVsc2V7XG5cbiAgICBsZXQgdGFnRW5kRXhwID0gJzwvJyArIGtleSArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICBsZXQgcGlDbG9zaW5nQ2hhciA9IFwiXCI7XG4gICAgXG4gICAgaWYoa2V5WzBdID09PSBcIj9cIikge1xuICAgICAgcGlDbG9zaW5nQ2hhciA9IFwiP1wiO1xuICAgICAgdGFnRW5kRXhwID0gXCJcIjtcbiAgICB9XG4gIFxuICAgIGlmIChhdHRyU3RyICYmIHZhbC5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gKCB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyAga2V5ICsgYXR0clN0ciArIHBpQ2xvc2luZ0NoYXIgKyAnPicgKyB2YWwgKyB0YWdFbmRFeHAgKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUgIT09IGZhbHNlICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSAmJiBwaUNsb3NpbmdDaGFyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIGA8IS0tJHt2YWx9LS0+YCArIHRoaXMubmV3TGluZTtcbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyBhdHRyU3RyICsgcGlDbG9zaW5nQ2hhciArIHRoaXMudGFnRW5kQ2hhciArXG4gICAgICAgIHZhbCArXG4gICAgICAgIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIHRhZ0VuZEV4cCAgICApO1xuICAgIH1cbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5jbG9zZVRhZyA9IGZ1bmN0aW9uKGtleSl7XG4gIGxldCBjbG9zZVRhZyA9IFwiXCI7XG4gIGlmKHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihrZXkpICE9PSAtMSl7IC8vdW5wYWlyZWRcbiAgICBpZighdGhpcy5vcHRpb25zLnN1cHByZXNzVW5wYWlyZWROb2RlKSBjbG9zZVRhZyA9IFwiL1wiXG4gIH1lbHNlIGlmKHRoaXMub3B0aW9ucy5zdXBwcmVzc0VtcHR5Tm9kZSl7IC8vZW1wdHlcbiAgICBjbG9zZVRhZyA9IFwiL1wiO1xuICB9ZWxzZXtcbiAgICBjbG9zZVRhZyA9IGA+PC8ke2tleX1gXG4gIH1cbiAgcmV0dXJuIGNsb3NlVGFnO1xufVxuXG5mdW5jdGlvbiBidWlsZEVtcHR5T2JqTm9kZSh2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYgKHZhbCAhPT0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZE9iamVjdE5vZGUodmFsLCBrZXksIGF0dHJTdHIsIGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICBpZihrZXlbMF0gPT09IFwiP1wiKSByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgIC8vIHJldHVybiB0aGlzLmJ1aWxkVGFnU3RyKGxldmVsLGtleSwgYXR0clN0cik7XG4gICAgfVxuICB9XG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkVGV4dFZhbE5vZGUgPSBmdW5jdGlvbih2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lICE9PSBmYWxzZSAmJiBrZXkgPT09IHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIGA8IVtDREFUQVske3ZhbH1dXT5gICsgIHRoaXMubmV3TGluZTtcbiAgfWVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUgIT09IGZhbHNlICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyBgPCEtLSR7dmFsfS0tPmAgKyAgdGhpcy5uZXdMaW5lO1xuICB9ZWxzZSBpZihrZXlbMF0gPT09IFwiP1wiKSB7Ly9QSSB0YWdcbiAgICByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjsgXG4gIH1lbHNle1xuICAgIGxldCB0ZXh0VmFsdWUgPSB0aGlzLm9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3Ioa2V5LCB2YWwpO1xuICAgIHRleHRWYWx1ZSA9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUodGV4dFZhbHVlKTtcbiAgXG4gICAgaWYoIHRleHRWYWx1ZSA9PT0gJycpe1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIgKyB0aGlzLmNsb3NlVGFnKGtleSkgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArICc+JyArXG4gICAgICAgICB0ZXh0VmFsdWUgK1xuICAgICAgICAnPC8nICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIH1cbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5yZXBsYWNlRW50aXRpZXNWYWx1ZSA9IGZ1bmN0aW9uKHRleHRWYWx1ZSl7XG4gIGlmKHRleHRWYWx1ZSAmJiB0ZXh0VmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLm9wdGlvbnMucHJvY2Vzc0VudGl0aWVzKXtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5vcHRpb25zLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLm9wdGlvbnMuZW50aXRpZXNbaV07XG4gICAgICB0ZXh0VmFsdWUgPSB0ZXh0VmFsdWUucmVwbGFjZShlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbmRlbnRhdGUobGV2ZWwpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmRlbnRCeS5yZXBlYXQobGV2ZWwpO1xufVxuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZShuYW1lIC8qLCBvcHRpb25zKi8pIHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCh0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeCkpIHtcbiAgICByZXR1cm4gbmFtZS5zdWJzdHIodGhpcy5hdHRyUHJlZml4TGVuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyO1xuIl0sIm5hbWVzIjpbImJ1aWxkRnJvbU9yZGVyZWRKcyIsInJlcXVpcmUiLCJkZWZhdWx0T3B0aW9ucyIsImF0dHJpYnV0ZU5hbWVQcmVmaXgiLCJhdHRyaWJ1dGVzR3JvdXBOYW1lIiwidGV4dE5vZGVOYW1lIiwiaWdub3JlQXR0cmlidXRlcyIsImNkYXRhUHJvcE5hbWUiLCJmb3JtYXQiLCJpbmRlbnRCeSIsInN1cHByZXNzRW1wdHlOb2RlIiwic3VwcHJlc3NVbnBhaXJlZE5vZGUiLCJzdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzIiwidGFnVmFsdWVQcm9jZXNzb3IiLCJrZXkiLCJhIiwiYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IiLCJhdHRyTmFtZSIsInByZXNlcnZlT3JkZXIiLCJjb21tZW50UHJvcE5hbWUiLCJ1bnBhaXJlZFRhZ3MiLCJlbnRpdGllcyIsInJlZ2V4IiwiUmVnRXhwIiwidmFsIiwicHJvY2Vzc0VudGl0aWVzIiwic3RvcE5vZGVzIiwib25lTGlzdEdyb3VwIiwiQnVpbGRlciIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJpc0F0dHJpYnV0ZSIsImF0dHJQcmVmaXhMZW4iLCJsZW5ndGgiLCJwcm9jZXNzVGV4dE9yT2JqTm9kZSIsImluZGVudGF0ZSIsInRhZ0VuZENoYXIiLCJuZXdMaW5lIiwicHJvdG90eXBlIiwiYnVpbGQiLCJqT2JqIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXlOb2RlTmFtZSIsImoyeCIsImxldmVsIiwiYXR0clN0ciIsIkRhdGUiLCJidWlsZFRleHRWYWxOb2RlIiwiYXR0ciIsImJ1aWxkQXR0clBhaXJTdHIiLCJuZXd2YWwiLCJyZXBsYWNlRW50aXRpZXNWYWx1ZSIsImFyckxlbiIsImxpc3RUYWdWYWwiLCJqIiwiaXRlbSIsImJ1aWxkT2JqZWN0Tm9kZSIsIktzIiwia2V5cyIsIkwiLCJvYmplY3QiLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJjbG9zZVRhZyIsInRhZ0VuZEV4cCIsInBpQ2xvc2luZ0NoYXIiLCJpbmRleE9mIiwiYnVpbGRFbXB0eU9iak5vZGUiLCJ0ZXh0VmFsdWUiLCJpIiwiZW50aXR5IiwicmVwbGFjZSIsInJlcGVhdCIsIm5hbWUiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js ***!
  \*******************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst EOL = \"\\n\";\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */ function toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n    for(let i = 0; i < arr.length; i++){\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName;\n        else newJPath = `${jPath}.${tagName}`;\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n    return xmlStr;\n}\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for(let attr in attrMap){\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for(let index in options.stopNodes){\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for(let i = 0; i < options.entities.length; i++){\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL29yZGVyZWRKczJYbWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE1BQU07QUFFWjs7Ozs7Q0FLQyxHQUNELFNBQVNDLE1BQU1DLE1BQU0sRUFBRUMsT0FBTztJQUMxQixJQUFJQyxjQUFjO0lBQ2xCLElBQUlELFFBQVFFLE1BQU0sSUFBSUYsUUFBUUcsUUFBUSxDQUFDQyxNQUFNLEdBQUcsR0FBRztRQUMvQ0gsY0FBY0o7SUFDbEI7SUFDQSxPQUFPUSxTQUFTTixRQUFRQyxTQUFTLElBQUlDO0FBQ3pDO0FBRUEsU0FBU0ksU0FBU0MsR0FBRyxFQUFFTixPQUFPLEVBQUVPLEtBQUssRUFBRU4sV0FBVztJQUM5QyxJQUFJTyxTQUFTO0lBQ2IsSUFBSUMsdUJBQXVCO0lBRTNCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixJQUFJRixNQUFNLEVBQUVNLElBQUs7UUFDakMsTUFBTUMsU0FBU0wsR0FBRyxDQUFDSSxFQUFFO1FBQ3JCLE1BQU1FLFVBQVVDLFNBQVNGO1FBQ3pCLElBQUlHLFdBQVc7UUFDZixJQUFJUCxNQUFNSCxNQUFNLEtBQUssR0FBR1UsV0FBV0Y7YUFDOUJFLFdBQVcsQ0FBQyxFQUFFUCxNQUFNLENBQUMsRUFBRUssUUFBUSxDQUFDO1FBRXJDLElBQUlBLFlBQVlaLFFBQVFlLFlBQVksRUFBRTtZQUNsQyxJQUFJQyxVQUFVTCxNQUFNLENBQUNDLFFBQVE7WUFDN0IsSUFBSSxDQUFDSyxXQUFXSCxVQUFVZCxVQUFVO2dCQUNoQ2dCLFVBQVVoQixRQUFRa0IsaUJBQWlCLENBQUNOLFNBQVNJO2dCQUM3Q0EsVUFBVUcscUJBQXFCSCxTQUFTaEI7WUFDNUM7WUFDQSxJQUFJUyxzQkFBc0I7Z0JBQ3RCRCxVQUFVUDtZQUNkO1lBQ0FPLFVBQVVRO1lBQ1ZQLHVCQUF1QjtZ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QUFJVixRQUFRcUQsUUFBUSxDQUFDakQsTUFBTSxFQUFFTSxJQUFLO1lBQzlDLE1BQU00QyxTQUFTdEQsUUFBUXFELFFBQVEsQ0FBQzNDLEVBQUU7WUFDbEN5QyxZQUFZQSxVQUFVSSxPQUFPLENBQUNELE9BQU9FLEtBQUssRUFBRUYsT0FBT0csR0FBRztRQUMxRDtJQUNKO0lBQ0EsT0FBT047QUFDWDtBQUNBTyxPQUFPQyxPQUFPLEdBQUc3RCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC14bWwtcGFyc2VyQDQuMi41L25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbGJ1aWxkZXIvb3JkZXJlZEpzMlhtbC5qcz9mN2E4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVPTCA9IFwiXFxuXCI7XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge2FycmF5fSBqQXJyYXkgXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9ucyBcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiB0b1htbChqQXJyYXksIG9wdGlvbnMpIHtcbiAgICBsZXQgaW5kZW50YXRpb24gPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmZvcm1hdCAmJiBvcHRpb25zLmluZGVudEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5kZW50YXRpb24gPSBFT0w7XG4gICAgfVxuICAgIHJldHVybiBhcnJUb1N0cihqQXJyYXksIG9wdGlvbnMsIFwiXCIsIGluZGVudGF0aW9uKTtcbn1cblxuZnVuY3Rpb24gYXJyVG9TdHIoYXJyLCBvcHRpb25zLCBqUGF0aCwgaW5kZW50YXRpb24pIHtcbiAgICBsZXQgeG1sU3RyID0gXCJcIjtcbiAgICBsZXQgaXNQcmV2aW91c0VsZW1lbnRUYWcgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IGFycltpXTtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHByb3BOYW1lKHRhZ09iaik7XG4gICAgICAgIGxldCBuZXdKUGF0aCA9IFwiXCI7XG4gICAgICAgIGlmIChqUGF0aC5sZW5ndGggPT09IDApIG5ld0pQYXRoID0gdGFnTmFtZVxuICAgICAgICBlbHNlIG5ld0pQYXRoID0gYCR7alBhdGh9LiR7dGFnTmFtZX1gO1xuXG4gICAgICAgIGlmICh0YWdOYW1lID09PSBvcHRpb25zLnRleHROb2RlTmFtZSkge1xuICAgICAgICAgICAgbGV0IHRhZ1RleHQgPSB0YWdPYmpbdGFnTmFtZV07XG4gICAgICAgICAgICBpZiAoIWlzU3RvcE5vZGUobmV3SlBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGFnVGV4dCA9IG9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3IodGFnTmFtZSwgdGFnVGV4dCk7XG4gICAgICAgICAgICAgICAgdGFnVGV4dCA9IHJlcGxhY2VFbnRpdGllc1ZhbHVlKHRhZ1RleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJldmlvdXNFbGVtZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgeG1sU3RyICs9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeG1sU3RyICs9IHRhZ1RleHQ7XG4gICAgICAgICAgICBpc1ByZXZpb3VzRWxlbWVudFRhZyA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gb3B0aW9ucy5jZGF0YVByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmV2aW91c0VsZW1lbnRUYWcpIHtcbiAgICAgICAgICAgICAgICB4bWxTdHIgKz0gaW5kZW50YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWxTdHIgKz0gYDwhW0NEQVRBWyR7dGFnT2JqW3RhZ05hbWVdWzBdW29wdGlvbnMudGV4dE5vZGVOYW1lXX1dXT5gO1xuICAgICAgICAgICAgaXNQcmV2aW91c0VsZW1lbnRUYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IG9wdGlvbnMuY29tbWVudFByb3BOYW1lKSB7XG4gICAgICAgICAgICB4bWxTdHIgKz0gaW5kZW50YXRpb24gKyBgPCEtLSR7dGFnT2JqW3RhZ05hbWVdWzBdW29wdGlvbnMudGV4dE5vZGVOYW1lXX0tLT5gO1xuICAgICAgICAgICAgaXNQcmV2aW91c0VsZW1lbnRUYWcgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZVswXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dFN0ciA9IGF0dHJfdG9fc3RyKHRhZ09ialtcIjpAXCJdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBJbmQgPSB0YWdOYW1lID09PSBcIj94bWxcIiA/IFwiXCIgOiBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGxldCBwaVRleHROb2RlTmFtZSA9IHRhZ09ialt0YWdOYW1lXVswXVtvcHRpb25zLnRleHROb2RlTmFtZV07XG4gICAgICAgICAgICBwaVRleHROb2RlTmFtZSA9IHBpVGV4dE5vZGVOYW1lLmxlbmd0aCAhPT0gMCA/IFwiIFwiICsgcGlUZXh0Tm9kZU5hbWUgOiBcIlwiOyAvL3JlbW92ZSBleHRyYSBzcGFjaW5nXG4gICAgICAgICAgICB4bWxTdHIgKz0gdGVtcEluZCArIGA8JHt0YWdOYW1lfSR7cGlUZXh0Tm9kZU5hbWV9JHthdHRTdHJ9Pz5gO1xuICAgICAgICAgICAgaXNQcmV2aW91c0VsZW1lbnRUYWcgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0lkZW50YXRpb24gPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgaWYgKG5ld0lkZW50YXRpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIG5ld0lkZW50YXRpb24gKz0gb3B0aW9ucy5pbmRlbnRCeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRTdHIgPSBhdHRyX3RvX3N0cih0YWdPYmpbXCI6QFwiXSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHRhZ1N0YXJ0ID0gaW5kZW50YXRpb24gKyBgPCR7dGFnTmFtZX0ke2F0dFN0cn1gO1xuICAgICAgICBjb25zdCB0YWdWYWx1ZSA9IGFyclRvU3RyKHRhZ09ialt0YWdOYW1lXSwgb3B0aW9ucywgbmV3SlBhdGgsIG5ld0lkZW50YXRpb24pO1xuICAgICAgICBpZiAob3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzVW5wYWlyZWROb2RlKSB4bWxTdHIgKz0gdGFnU3RhcnQgKyBcIj5cIjtcbiAgICAgICAgICAgIGVsc2UgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgXCIvPlwiO1xuICAgICAgICB9IGVsc2UgaWYgKCghdGFnVmFsdWUgfHwgdGFnVmFsdWUubGVuZ3RoID09PSAwKSAmJiBvcHRpb25zLnN1cHByZXNzRW1wdHlOb2RlKSB7XG4gICAgICAgICAgICB4bWxTdHIgKz0gdGFnU3RhcnQgKyBcIi8+XCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnVmFsdWUgJiYgdGFnVmFsdWUuZW5kc1dpdGgoXCI+XCIpKSB7XG4gICAgICAgICAgICB4bWxTdHIgKz0gdGFnU3RhcnQgKyBgPiR7dGFnVmFsdWV9JHtpbmRlbnRhdGlvbn08LyR7dGFnTmFtZX0+YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhtbFN0ciArPSB0YWdTdGFydCArIFwiPlwiO1xuICAgICAgICAgICAgaWYgKHRhZ1ZhbHVlICYmIGluZGVudGF0aW9uICE9PSBcIlwiICYmICh0YWdWYWx1ZS5pbmNsdWRlcyhcIi8+XCIpIHx8IHRhZ1ZhbHVlLmluY2x1ZGVzKFwiPC9cIikpKSB7XG4gICAgICAgICAgICAgICAgeG1sU3RyICs9IGluZGVudGF0aW9uICsgb3B0aW9ucy5pbmRlbnRCeSArIHRhZ1ZhbHVlICsgaW5kZW50YXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhtbFN0ciArPSB0YWdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhtbFN0ciArPSBgPC8ke3RhZ05hbWV9PmA7XG4gICAgICAgIH1cbiAgICAgICAgaXNQcmV2aW91c0VsZW1lbnRUYWcgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB4bWxTdHI7XG59XG5cbmZ1bmN0aW9uIHByb3BOYW1lKG9iaikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ICE9PSBcIjpAXCIpIHJldHVybiBrZXk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhdHRyX3RvX3N0cihhdHRyTWFwLCBvcHRpb25zKSB7XG4gICAgbGV0IGF0dHJTdHIgPSBcIlwiO1xuICAgIGlmIChhdHRyTWFwICYmICFvcHRpb25zLmlnbm9yZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yIChsZXQgYXR0ciBpbiBhdHRyTWFwKSB7XG4gICAgICAgICAgICBsZXQgYXR0clZhbCA9IG9wdGlvbnMuYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IoYXR0ciwgYXR0ck1hcFthdHRyXSk7XG4gICAgICAgICAgICBhdHRyVmFsID0gcmVwbGFjZUVudGl0aWVzVmFsdWUoYXR0clZhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYXR0clZhbCA9PT0gdHJ1ZSAmJiBvcHRpb25zLnN1cHByZXNzQm9vbGVhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBhdHRyU3RyICs9IGAgJHthdHRyLnN1YnN0cihvcHRpb25zLmF0dHJpYnV0ZU5hbWVQcmVmaXgubGVuZ3RoKX1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyU3RyICs9IGAgJHthdHRyLnN1YnN0cihvcHRpb25zLmF0dHJpYnV0ZU5hbWVQcmVmaXgubGVuZ3RoKX09XCIke2F0dHJWYWx9XCJgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdHRyU3RyO1xufVxuXG5mdW5jdGlvbiBpc1N0b3BOb2RlKGpQYXRoLCBvcHRpb25zKSB7XG4gICAgalBhdGggPSBqUGF0aC5zdWJzdHIoMCwgalBhdGgubGVuZ3RoIC0gb3B0aW9ucy50ZXh0Tm9kZU5hbWUubGVuZ3RoIC0gMSk7XG4gICAgbGV0IHRhZ05hbWUgPSBqUGF0aC5zdWJzdHIoalBhdGgubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgZm9yIChsZXQgaW5kZXggaW4gb3B0aW9ucy5zdG9wTm9kZXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RvcE5vZGVzW2luZGV4XSA9PT0galBhdGggfHwgb3B0aW9ucy5zdG9wTm9kZXNbaW5kZXhdID09PSBcIiouXCIgKyB0YWdOYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRW50aXRpZXNWYWx1ZSh0ZXh0VmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodGV4dFZhbHVlICYmIHRleHRWYWx1ZS5sZW5ndGggPiAwICYmIG9wdGlvbnMucHJvY2Vzc0VudGl0aWVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5lbnRpdGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gb3B0aW9ucy5lbnRpdGllc1tpXTtcbiAgICAgICAgICAgIHRleHRWYWx1ZSA9IHRleHRWYWx1ZS5yZXBsYWNlKGVudGl0eS5yZWdleCwgZW50aXR5LnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRWYWx1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gdG9YbWw7XG4iXSwibmFtZXMiOlsiRU9MIiwidG9YbWwiLCJqQXJyYXkiLCJvcHRpb25zIiwiaW5kZW50YXRpb24iLCJmb3JtYXQiLCJpbmRlbnRCeSIsImxlbmd0aCIsImFyclRvU3RyIiwiYXJyIiwialBhdGgiLCJ4bWxTdHIiLCJpc1ByZXZpb3VzRWxlbWVudFRhZyIsImkiLCJ0YWdPYmoiLCJ0YWdOYW1lIiwicHJvcE5hbWUiLCJuZXdKUGF0aCIsInRleHROb2RlTmFtZSIsInRhZ1RleHQiLCJpc1N0b3BOb2RlIiwidGFnVmFsdWVQcm9jZXNzb3IiLCJyZXBsYWNlRW50aXRpZXNWYWx1ZSIsImNkYXRhUHJvcE5hbWUiLCJjb21tZW50UHJvcE5hbWUiLCJhdHRTdHIiLCJhdHRyX3RvX3N0ciIsInRlbXBJbmQiLCJwaVRleHROb2RlTmFtZSIsIm5ld0lkZW50YXRpb24iLCJ0YWdTdGFydCIsInRhZ1ZhbHVlIiwidW5wYWlyZWRUYWdzIiwiaW5kZXhPZiIsInN1cHByZXNzVW5wYWlyZWROb2RlIiwic3VwcHJlc3NFbXB0eU5vZGUiLCJlbmRzV2l0aCIsImluY2x1ZGVzIiwib2JqIiwia2V5cyIsIk9iamVjdCIsImtleSIsImF0dHJNYXAiLCJhdHRyU3RyIiwiaWdub3JlQXR0cmlidXRlcyIsImF0dHIiLCJhdHRyVmFsIiwiYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IiLCJzdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzIiwic3Vic3RyIiwiYXR0cmlidXRlTmFtZVByZWZpeCIsImxhc3RJbmRleE9mIiwiaW5kZXgiLCJzdG9wTm9kZXMiLCJ0ZXh0VmFsdWUiLCJwcm9jZXNzRW50aXRpZXMiLCJlbnRpdGllcyIsImVudGl0eSIsInJlcGxhY2UiLCJyZWdleCIsInZhbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/util.js\");\n//TODO: handle comments\nfunction readDocType(xmlData, i) {\n    const entities = {};\n    if (xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"C\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"Y\" && xmlData[i + 7] === \"P\" && xmlData[i + 8] === \"E\") {\n        i = i + 9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\" && !comment) {\n                if (hasBody && isEntity(xmlData, i)) {\n                    i += 7;\n                    [entityName, val, i] = readEntityExp(xmlData, i + 1);\n                    if (val.indexOf(\"&\") === -1) entities[validateEntityName(entityName)] = {\n                        regx: RegExp(`&${entityName};`, \"g\"),\n                        val: val\n                    };\n                } else if (hasBody && isElement(xmlData, i)) i += 8; //Not supported\n                else if (hasBody && isAttlist(xmlData, i)) i += 8; //Not supported\n                else if (hasBody && isNotation(xmlData, i)) i += 9; //Not supported\n                else if (isComment) comment = true;\n                else throw new Error(\"Invalid DOCTYPE\");\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === \">\") {\n                if (comment) {\n                    if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                } else {\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            } else if (xmlData[i] === \"[\") {\n                hasBody = true;\n            } else {\n                exp += xmlData[i];\n            }\n        }\n        if (angleBracketsCount !== 0) {\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    } else {\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {\n        entities,\n        i\n    };\n}\nfunction readEntityExp(xmlData, i) {\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    //read EntityName\n    let entityName1 = \"\";\n    for(; i < xmlData.length && xmlData[i] !== \"'\" && xmlData[i] !== '\"'; i++){\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName1 += xmlData[i];\n    }\n    entityName1 = entityName1.trim();\n    if (entityName1.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val1 = \"\";\n    for(; i < xmlData.length && xmlData[i] !== startChar; i++){\n        val1 += xmlData[i];\n    }\n    return [\n        entityName1,\n        val1,\n        i\n    ];\n}\nfunction isComment(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"-\" && xmlData[i + 3] === \"-\") return true;\n    return false;\n}\nfunction isEntity(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"E\" && xmlData[i + 3] === \"N\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"I\" && xmlData[i + 6] === \"T\" && xmlData[i + 7] === \"Y\") return true;\n    return false;\n}\nfunction isElement(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"E\" && xmlData[i + 3] === \"L\" && xmlData[i + 4] === \"E\" && xmlData[i + 5] === \"M\" && xmlData[i + 6] === \"E\" && xmlData[i + 7] === \"N\" && xmlData[i + 8] === \"T\") return true;\n    return false;\n}\nfunction isAttlist(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"A\" && xmlData[i + 3] === \"T\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"L\" && xmlData[i + 6] === \"I\" && xmlData[i + 7] === \"S\" && xmlData[i + 8] === \"T\") return true;\n    return false;\n}\nfunction isNotation(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"N\" && xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"A\" && xmlData[i + 6] === \"T\" && xmlData[i + 7] === \"I\" && xmlData[i + 8] === \"O\" && xmlData[i + 9] === \"N\") return true;\n    return false;\n}\nfunction validateEntityName(name) {\n    if (util.isName(name)) return name;\n    else throw new Error(`Invalid entity name ${name}`);\n}\nmodule.exports = readDocType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvRG9jVHlwZVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFckIsdUJBQXVCO0FBQ3ZCLFNBQVNDLFlBQVlDLE9BQU8sRUFBRUMsQ0FBQztJQUUzQixNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSUYsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNsQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxLQUN4QjtRQUNJQSxJQUFJQSxJQUFFO1FBQ04sSUFBSUUscUJBQXFCO1FBQ3pCLElBQUlDLFVBQVUsT0FBT0MsVUFBVTtRQUMvQixJQUFJQyxNQUFNO1FBQ1YsTUFBS0wsSUFBRUQsUUFBUU8sTUFBTSxFQUFDTixJQUFJO1lBQ3RCLElBQUlELE9BQU8sQ0FBQ0MsRUFBRSxLQUFLLE9BQU8sQ0FBQ0ksU0FBUztnQkFDaEMsSUFBSUQsV0FBV0ksU0FBU1IsU0FBU0MsSUFBRztvQkFDaENBLEtBQUs7b0JBQ0wsQ0FBQ1EsWUFBWUMsS0FBSVQsRUFBRSxHQUFHVSxjQUFjWCxTQUFRQyxJQUFFO29CQUM5QyxJQUFHUyxJQUFJRSxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQ3JCVixRQUFRLENBQUVXLG1CQUFtQkosWUFBYSxHQUFHO3dCQUN6Q0ssTUFBT0MsT0FBUSxDQUFDLENBQUMsRUFBRU4sV0FBVyxDQUFDLENBQUMsRUFBQzt3QkFDakNDLEtBQUtBO29CQUNUO2dCQUNSLE9BQ0ssSUFBSU4sV0FBV1ksVUFB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S0FBSyxPQUNwQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxLQUFLLE9BQU87SUFDN0IsT0FBTztBQUNYO0FBRUEsU0FBU2dCLFVBQVVqQixPQUFPLEVBQUVDLENBQUM7SUFDekIsSUFBR0QsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNwQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxLQUFLLE9BQU87SUFDN0IsT0FBTztBQUNYO0FBQ0EsU0FBU2lCLFdBQVdsQixPQUFPLEVBQUVDLENBQUM7SUFDMUIsSUFBR0QsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNwQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxLQUFLLE9BQU87SUFDN0IsT0FBTztBQUNYO0FBRUEsU0FBU1ksbUJBQW1CVSxJQUFJO0lBQzVCLElBQUkxQixLQUFLMkIsTUFBTSxDQUFDRCxPQUNuQixPQUFPQTtTQUVBLE1BQU0sSUFBSUgsTUFBTSxDQUFDLG9CQUFvQixFQUFFRyxLQUFLLENBQUM7QUFDckQ7QUFFQUUsT0FBT0MsT0FBTyxHQUFHM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvRG9jVHlwZVJlYWRlci5qcz9lODQ1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8vVE9ETzogaGFuZGxlIGNvbW1lbnRzXG5mdW5jdGlvbiByZWFkRG9jVHlwZSh4bWxEYXRhLCBpKXtcbiAgICBcbiAgICBjb25zdCBlbnRpdGllcyA9IHt9O1xuICAgIGlmKCB4bWxEYXRhW2kgKyAzXSA9PT0gJ08nICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA0XSA9PT0gJ0MnICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA1XSA9PT0gJ1QnICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA2XSA9PT0gJ1knICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA3XSA9PT0gJ1AnICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA4XSA9PT0gJ0UnKVxuICAgIHsgICAgXG4gICAgICAgIGkgPSBpKzk7XG4gICAgICAgIGxldCBhbmdsZUJyYWNrZXRzQ291bnQgPSAxO1xuICAgICAgICBsZXQgaGFzQm9keSA9IGZhbHNlLCBjb21tZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBleHAgPSBcIlwiO1xuICAgICAgICBmb3IoO2k8eG1sRGF0YS5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcgJiYgIWNvbW1lbnQpIHsgLy9EZXRlcm1pbmUgdGhlIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgaWYoIGhhc0JvZHkgJiYgaXNFbnRpdHkoeG1sRGF0YSwgaSkpe1xuICAgICAgICAgICAgICAgICAgICBpICs9IDc7IFxuICAgICAgICAgICAgICAgICAgICBbZW50aXR5TmFtZSwgdmFsLGldID0gcmVhZEVudGl0eUV4cCh4bWxEYXRhLGkrMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbC5pbmRleE9mKFwiJlwiKSA9PT0gLTEpIC8vUGFyYW1ldGVyIGVudGl0aWVzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllc1sgdmFsaWRhdGVFbnRpdHlOYW1lKGVudGl0eU5hbWUpIF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVneCA6IFJlZ0V4cCggYCYke2VudGl0eU5hbWV9O2AsXCJnXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogdmFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKCBoYXNCb2R5ICYmIGlzRWxlbWVudCh4bWxEYXRhLCBpKSkgIGkgKz0gODsvL05vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBlbHNlIGlmKCBoYXNCb2R5ICYmIGlzQXR0bGlzdCh4bWxEYXRhLCBpKSkgIGkgKz0gODsvL05vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBlbHNlIGlmKCBoYXNCb2R5ICYmIGlzTm90YXRpb24oeG1sRGF0YSwgaSkpIGkgKz0gOTsvL05vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBlbHNlIGlmKCBpc0NvbW1lbnQpICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBET0NUWVBFXCIpO1xuXG4gICAgICAgICAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50Kys7XG4gICAgICAgICAgICAgICAgZXhwID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJz4nKSB7IC8vUmVhZCB0YWcgY29udGVudFxuICAgICAgICAgICAgICAgIGlmKGNvbW1lbnQpe1xuICAgICAgICAgICAgICAgICAgICBpZiggeG1sRGF0YVtpIC0gMV0gPT09IFwiLVwiICYmIHhtbERhdGFbaSAtIDJdID09PSBcIi1cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlQnJhY2tldHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2UgaWYoIHhtbERhdGFbaV0gPT09ICdbJyl7XG4gICAgICAgICAgICAgICAgaGFzQm9keSA9IHRydWU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBleHAgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihhbmdsZUJyYWNrZXRzQ291bnQgIT09IDApe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmNsb3NlZCBET0NUWVBFYCk7XG4gICAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFRhZyBpbnN0ZWFkIG9mIERPQ1RZUEVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtlbnRpdGllcywgaX07XG59XG5cbmZ1bmN0aW9uIHJlYWRFbnRpdHlFeHAoeG1sRGF0YSxpKXtcbiAgICAvL0V4dGVybmFsIGVudGl0aWVzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgLy8gICAgPCFFTlRJVFkgZXh0IFNZU1RFTSBcImh0dHA6Ly9ub3JtYWwtd2Vic2l0ZS5jb21cIiA+XG5cbiAgICAvL1BhcmFtZXRlciBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgIC8vICAgIDwhRU5USVRZIGVudGl0eW5hbWUgXCImYW5vdGhlckVsZW1lbnQ7XCI+XG5cbiAgICAvL0ludGVybmFsIGVudGl0aWVzIGFyZSBzdXBwb3J0ZWRcbiAgICAvLyAgICA8IUVOVElUWSBlbnRpdHluYW1lIFwicmVwbGFjZW1lbnQgdGV4dFwiPlxuICAgIFxuICAgIC8vcmVhZCBFbnRpdHlOYW1lXG4gICAgbGV0IGVudGl0eU5hbWUgPSBcIlwiO1xuICAgIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGggJiYgKHhtbERhdGFbaV0gIT09IFwiJ1wiICYmIHhtbERhdGFbaV0gIT09ICdcIicgKTsgaSsrKSB7XG4gICAgICAgIC8vIGlmKHhtbERhdGFbaV0gPT09IFwiIFwiKSBjb250aW51ZTtcbiAgICAgICAgLy8gZWxzZSBcbiAgICAgICAgZW50aXR5TmFtZSArPSB4bWxEYXRhW2ldO1xuICAgIH1cbiAgICBlbnRpdHlOYW1lID0gZW50aXR5TmFtZS50cmltKCk7XG4gICAgaWYoZW50aXR5TmFtZS5pbmRleE9mKFwiIFwiKSAhPT0gLTEpIHRocm93IG5ldyBFcnJvcihcIkV4dGVybmFsIGVudGl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG5cbiAgICAvL3JlYWQgRW50aXR5IFZhbHVlXG4gICAgY29uc3Qgc3RhcnRDaGFyID0geG1sRGF0YVtpKytdO1xuICAgIGxldCB2YWwgPSBcIlwiXG4gICAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aCAmJiB4bWxEYXRhW2ldICE9PSBzdGFydENoYXIgOyBpKyspIHtcbiAgICAgICAgdmFsICs9IHhtbERhdGFbaV07XG4gICAgfVxuICAgIHJldHVybiBbZW50aXR5TmFtZSwgdmFsLCBpXTtcbn1cblxuZnVuY3Rpb24gaXNDb21tZW50KHhtbERhdGEsIGkpe1xuICAgIGlmKHhtbERhdGFbaSsxXSA9PT0gJyEnICYmXG4gICAgeG1sRGF0YVtpKzJdID09PSAnLScgJiZcbiAgICB4bWxEYXRhW2krM10gPT09ICctJykgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2Vcbn1cbmZ1bmN0aW9uIGlzRW50aXR5KHhtbERhdGEsIGkpe1xuICAgIGlmKHhtbERhdGFbaSsxXSA9PT0gJyEnICYmXG4gICAgeG1sRGF0YVtpKzJdID09PSAnRScgJiZcbiAgICB4bWxEYXRhW2krM10gPT09ICdOJyAmJlxuICAgIHhtbERhdGFbaSs0XSA9PT0gJ1QnICYmXG4gICAgeG1sRGF0YVtpKzVdID09PSAnSScgJiZcbiAgICB4bWxEYXRhW2krNl0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSs3XSA9PT0gJ1knKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxufVxuZnVuY3Rpb24gaXNFbGVtZW50KHhtbERhdGEsIGkpe1xuICAgIGlmKHhtbERhdGFbaSsxXSA9PT0gJyEnICYmXG4gICAgeG1sRGF0YVtpKzJdID09PSAnRScgJiZcbiAgICB4bWxEYXRhW2krM10gPT09ICdMJyAmJlxuICAgIHhtbERhdGFbaSs0XSA9PT0gJ0UnICYmXG4gICAgeG1sRGF0YVtpKzVdID09PSAnTScgJiZcbiAgICB4bWxEYXRhW2krNl0gPT09ICdFJyAmJlxuICAgIHhtbERhdGFbaSs3XSA9PT0gJ04nICYmXG4gICAgeG1sRGF0YVtpKzhdID09PSAnVCcpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGlzQXR0bGlzdCh4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJ0EnICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krNF0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSs1XSA9PT0gJ0wnICYmXG4gICAgeG1sRGF0YVtpKzZdID09PSAnSScgJiZcbiAgICB4bWxEYXRhW2krN10gPT09ICdTJyAmJlxuICAgIHhtbERhdGFbaSs4XSA9PT0gJ1QnKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxufVxuZnVuY3Rpb24gaXNOb3RhdGlvbih4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJ04nICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnTycgJiZcbiAgICB4bWxEYXRhW2krNF0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSs1XSA9PT0gJ0EnICYmXG4gICAgeG1sRGF0YVtpKzZdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krN10gPT09ICdJJyAmJlxuICAgIHhtbERhdGFbaSs4XSA9PT0gJ08nICYmXG4gICAgeG1sRGF0YVtpKzldID09PSAnTicpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW50aXR5TmFtZShuYW1lKXtcbiAgICBpZiAodXRpbC5pc05hbWUobmFtZSkpXG5cdHJldHVybiBuYW1lO1xuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVudGl0eSBuYW1lICR7bmFtZX1gKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFkRG9jVHlwZTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsInJlYWREb2NUeXBlIiwieG1sRGF0YSIsImkiLCJlbnRpdGllcyIsImFuZ2xlQnJhY2tldHNDb3VudCIsImhhc0JvZHkiLCJjb21tZW50IiwiZXhwIiwibGVuZ3RoIiwiaXNFbnRpdHkiLCJlbnRpdHlOYW1lIiwidmFsIiwicmVhZEVudGl0eUV4cCIsImluZGV4T2YiLCJ2YWxpZGF0ZUVudGl0eU5hbWUiLCJyZWd4IiwiUmVnRXhwIiwiaXNFbGVtZW50IiwiaXNBdHRsaXN0IiwiaXNOb3RhdGlvbiIsImlzQ29tbWVudCIsIkVycm9yIiwidHJpbSIsInN0YXJ0Q2hhciIsIm5hbWUiLCJpc05hbWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: \"@_\",\n    attributesGroupName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    removeNSPrefix: false,\n    allowBooleanAttributes: false,\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true,\n    cdataPropName: false,\n    numberParseOptions: {\n        hex: true,\n        leadingZeros: true,\n        eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n        return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n        return val;\n    },\n    stopNodes: [],\n    alwaysCreateTextNode: false,\n    isArray: ()=>false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs) {\n        return tagName;\n    }\n};\nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3B0aW9uc0J1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQ0EsTUFBTUEsaUJBQWlCO0lBQ25CQyxlQUFlO0lBQ2ZDLHFCQUFxQjtJQUNyQkMscUJBQXFCO0lBQ3JCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyx3QkFBd0I7SUFDeEIsNEJBQTRCO0lBQzVCQyxlQUFlO0lBQ2ZDLHFCQUFxQjtJQUNyQkMsWUFBWTtJQUNaQyxlQUFlO0lBQ2ZDLG9CQUFvQjtRQUNsQkMsS0FBSztRQUNMQyxjQUFjO1FBQ2RDLFdBQVc7SUFDYjtJQUNBQyxtQkFBbUIsU0FBU0MsT0FBTyxFQUFFQyxHQUFHO1FBQ3RDLE9BQU9BO0lBQ1Q7SUFDQUMseUJBQXlCLFNBQVNDLFFBQVEsRUFBRUYsR0FBRztRQUM3QyxPQUFPQTtJQUNUO0lBQ0FHLFdBQVcsRUFBRTtJQUNiQyxzQkFBc0I7SUFDdEJDLFNBQVMsSUFBTTtJQUNmQyxpQkFBaUI7SUFDakJDLGNBQWMsRUFBRTtJQUNoQkMsaUJBQWlCO0lBQ2pCQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMsY0FBYztJQUNkQyxrQkFBa0I7SUFDbEJDLHdCQUF3QjtJQUN4QkMsV0FBVyxTQUFTZixPQUFPLEVBQUVnQixLQUFLLEVBQUVDLEtBQUs7UUFDdkMsT0FBT2pCO0lBQ1Q7QUFFSjtBQUVBLE1BQU1rQixlQUFlLFNBQVNDLE9BQU87SUFDakMsT0FBT0MsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR3RDLGdCQUFnQm9DO0FBQzdDO0FBRUFHLG9CQUFvQixHQUFHSjtBQUN2Qkksc0JBQXNCLEdBQUd2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC14bWwtcGFyc2VyQDQuMi41L25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9PcHRpb25zQnVpbGRlci5qcz9hYzY3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcHJlc2VydmVPcmRlcjogZmFsc2UsXG4gICAgYXR0cmlidXRlTmFtZVByZWZpeDogJ0BfJyxcbiAgICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBmYWxzZSxcbiAgICB0ZXh0Tm9kZU5hbWU6ICcjdGV4dCcsXG4gICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZSxcbiAgICByZW1vdmVOU1ByZWZpeDogZmFsc2UsIC8vIHJlbW92ZSBOUyBmcm9tIHRhZyBuYW1lIG9yIGF0dHJpYnV0ZSBuYW1lIGlmIHRydWVcbiAgICBhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzOiBmYWxzZSwgLy9hIHRhZyBjYW4gaGF2ZSBhdHRyaWJ1dGVzIHdpdGhvdXQgYW55IHZhbHVlXG4gICAgLy9pZ25vcmVSb290RWxlbWVudCA6IGZhbHNlLFxuICAgIHBhcnNlVGFnVmFsdWU6IHRydWUsXG4gICAgcGFyc2VBdHRyaWJ1dGVWYWx1ZTogZmFsc2UsXG4gICAgdHJpbVZhbHVlczogdHJ1ZSwgLy9UcmltIHN0cmluZyB2YWx1ZXMgb2YgdGFnIGFuZCBhdHRyaWJ1dGVzXG4gICAgY2RhdGFQcm9wTmFtZTogZmFsc2UsXG4gICAgbnVtYmVyUGFyc2VPcHRpb25zOiB7XG4gICAgICBoZXg6IHRydWUsXG4gICAgICBsZWFkaW5nWmVyb3M6IHRydWUsXG4gICAgICBlTm90YXRpb246IHRydWVcbiAgICB9LFxuICAgIHRhZ1ZhbHVlUHJvY2Vzc29yOiBmdW5jdGlvbih0YWdOYW1lLCB2YWwpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcbiAgICBhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcjogZnVuY3Rpb24oYXR0ck5hbWUsIHZhbCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuICAgIHN0b3BOb2RlczogW10sIC8vbmVzdGVkIHRhZ3Mgd2lsbCBub3QgYmUgcGFyc2VkIGV2ZW4gZm9yIGVycm9yc1xuICAgIGFsd2F5c0NyZWF0ZVRleHROb2RlOiBmYWxzZSxcbiAgICBpc0FycmF5OiAoKSA9PiBmYWxzZSxcbiAgICBjb21tZW50UHJvcE5hbWU6IGZhbHNlLFxuICAgIHVucGFpcmVkVGFnczogW10sXG4gICAgcHJvY2Vzc0VudGl0aWVzOiB0cnVlLFxuICAgIGh0bWxFbnRpdGllczogZmFsc2UsXG4gICAgaWdub3JlRGVjbGFyYXRpb246IGZhbHNlLFxuICAgIGlnbm9yZVBpVGFnczogZmFsc2UsXG4gICAgdHJhbnNmb3JtVGFnTmFtZTogZmFsc2UsXG4gICAgdHJhbnNmb3JtQXR0cmlidXRlTmFtZTogZmFsc2UsXG4gICAgdXBkYXRlVGFnOiBmdW5jdGlvbih0YWdOYW1lLCBqUGF0aCwgYXR0cnMpe1xuICAgICAgcmV0dXJuIHRhZ05hbWVcbiAgICB9LFxuICAgIC8vIHNraXBFbXB0eUxpc3RJdGVtOiBmYWxzZVxufTtcbiAgIFxuY29uc3QgYnVpbGRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG59O1xuXG5leHBvcnRzLmJ1aWxkT3B0aW9ucyA9IGJ1aWxkT3B0aW9ucztcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9uczsiXSwibmFtZXMiOlsiZGVmYXVsdE9wdGlvbnMiLCJwcmVzZXJ2ZU9yZGVyIiwiYXR0cmlidXRlTmFtZVByZWZpeCIsImF0dHJpYnV0ZXNHcm91cE5hbWUiLCJ0ZXh0Tm9kZU5hbWUiLCJpZ25vcmVBdHRyaWJ1dGVzIiwicmVtb3ZlTlNQcmVmaXgiLCJhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzIiwicGFyc2VUYWdWYWx1ZSIsInBhcnNlQXR0cmlidXRlVmFsdWUiLCJ0cmltVmFsdWVzIiwiY2RhdGFQcm9wTmFtZSIsIm51bWJlclBhcnNlT3B0aW9ucyIsImhleCIsImxlYWRpbmdaZXJvcyIsImVOb3RhdGlvbiIsInRhZ1ZhbHVlUHJvY2Vzc29yIiwidGFnTmFtZSIsInZhbCIsImF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yIiwiYXR0ck5hbWUiLCJzdG9wTm9kZXMiLCJhbHdheXNDcmVhdGVUZXh0Tm9kZSIsImlzQXJyYXkiLCJjb21tZW50UHJvcE5hbWUiLCJ1bnBhaXJlZFRhZ3MiLCJwcm9jZXNzRW50aXRpZXMiLCJodG1sRW50aXRpZXMiLCJpZ25vcmVEZWNsYXJhdGlvbiIsImlnbm9yZVBpVGFncyIsInRyYW5zZm9ybVRhZ05hbWUiLCJ0cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lIiwidXBkYXRlVGFnIiwialBhdGgiLCJhdHRycyIsImJ1aWxkT3B0aW9ucyIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n///@ts-check\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/util.js\");\nconst xmlNode = __webpack_require__(/*! ./xmlNode */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\nconst readDocType = __webpack_require__(/*! ./DocTypeReader */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\");\nconst toNumber = __webpack_require__(/*! strnum */ \"(rsc)/../../node_modules/.pnpm/strnum@1.0.5/node_modules/strnum/strnum.js\");\nconst regx = \"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)\".replace(/NAME/g, util.nameRegexp);\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\nclass OrderedObjParser {\n    constructor(options){\n        this.options = options;\n        this.currentNode = null;\n        this.tagsNodeStack = [];\n        this.docTypeEntities = {};\n        this.lastEntities = {\n            \"apos\": {\n                regex: /&(apos|#39|#x27);/g,\n                val: \"'\"\n            },\n            \"gt\": {\n                regex: /&(gt|#62|#x3E);/g,\n                val: \">\"\n            },\n            \"lt\": {\n                regex: /&(lt|#60|#x3C);/g,\n                val: \"<\"\n            },\n            \"quot\": {\n                regex: /&(quot|#34|#x22);/g,\n                val: '\"'\n            }\n        };\n        this.ampEntity = {\n            regex: /&(amp|#38|#x26);/g,\n            val: \"&\"\n        };\n        this.htmlEntities = {\n            \"space\": {\n                regex: /&(nbsp|#160);/g,\n                val: \" \"\n            },\n            // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n            // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n            // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n            // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n            // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n            \"cent\": {\n                regex: /&(cent|#162);/g,\n                val: \"\\xa2\"\n            },\n            \"pound\": {\n                regex: /&(pound|#163);/g,\n                val: \"\\xa3\"\n            },\n            \"yen\": {\n                regex: /&(yen|#165);/g,\n                val: \"\\xa5\"\n            },\n            \"euro\": {\n                regex: /&(euro|#8364);/g,\n                val: \"\"\n            },\n            \"copyright\": {\n                regex: /&(copy|#169);/g,\n                val: \"\\xa9\"\n            },\n            \"reg\": {\n                regex: /&(reg|#174);/g,\n                val: \"\\xae\"\n            },\n            \"inr\": {\n                regex: /&(inr|#8377);/g,\n                val: \"\"\n            }\n        };\n        this.addExternalEntities = addExternalEntities;\n        this.parseXml = parseXml;\n        this.parseTextData = parseTextData;\n        this.resolveNameSpace = resolveNameSpace;\n        this.buildAttributesMap = buildAttributesMap;\n        this.isItStopNode = isItStopNode;\n        this.replaceEntitiesValue = replaceEntitiesValue;\n        this.readStopNodeData = readStopNodeData;\n        this.saveTextToParentTag = saveTextToParentTag;\n        this.addChild = addChild;\n    }\n}\nfunction addExternalEntities(externalEntities) {\n    const entKeys = Object.keys(externalEntities);\n    for(let i = 0; i < entKeys.length; i++){\n        const ent = entKeys[i];\n        this.lastEntities[ent] = {\n            regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n            val: externalEntities[ent]\n        };\n    }\n}\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */ function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n    if (val !== undefined) {\n        if (this.options.trimValues && !dontTrim) {\n            val = val.trim();\n        }\n        if (val.length > 0) {\n            if (!escapeEntities) val = this.replaceEntitiesValue(val);\n            const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n            if (newval === null || newval === undefined) {\n                //don't parse\n                return val;\n            } else if (typeof newval !== typeof val || newval !== val) {\n                //overwrite\n                return newval;\n            } else if (this.options.trimValues) {\n                return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n            } else {\n                const trimmedVal = val.trim();\n                if (trimmedVal === val) {\n                    return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n                } else {\n                    return val;\n                }\n            }\n        }\n    }\n}\nfunction resolveNameSpace(tagname) {\n    if (this.options.removeNSPrefix) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\", \"gm\");\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n    if (!this.options.ignoreAttributes && typeof attrStr === \"string\") {\n        // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n        //attrStr = attrStr || attrStr.trim();\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for(let i = 0; i < len; i++){\n            const attrName = this.resolveNameSpace(matches[i][1]);\n            let oldVal = matches[i][4];\n            let aName = this.options.attributeNamePrefix + attrName;\n            if (attrName.length) {\n                if (this.options.transformAttributeName) {\n                    aName = this.options.transformAttributeName(aName);\n                }\n                if (aName === \"__proto__\") aName = \"#__proto__\";\n                if (oldVal !== undefined) {\n                    if (this.options.trimValues) {\n                        oldVal = oldVal.trim();\n                    }\n                    oldVal = this.replaceEntitiesValue(oldVal);\n                    const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n                    if (newVal === null || newVal === undefined) {\n                        //don't parse\n                        attrs[aName] = oldVal;\n                    } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n                        //overwrite\n                        attrs[aName] = newVal;\n                    } else {\n                        //parse\n                        attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n                    }\n                } else if (this.options.allowBooleanAttributes) {\n                    attrs[aName] = true;\n                }\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (this.options.attributesGroupName) {\n            const attrCollection = {};\n            attrCollection[this.options.attributesGroupName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\nconst parseXml = function(xmlData) {\n    xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n    const xmlObj = new xmlNode(\"!xml\");\n    let currentNode = xmlObj;\n    let textData = \"\";\n    let jPath = \"\";\n    for(let i = 0; i < xmlData.length; i++){\n        const ch = xmlData[i];\n        if (ch === \"<\") {\n            // const nextIndex = i+1;\n            // const _2ndChar = xmlData[nextIndex];\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n                let tagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (this.options.removeNSPrefix) {\n                    const colonIndex = tagName.indexOf(\":\");\n                    if (colonIndex !== -1) {\n                        tagName = tagName.substr(colonIndex + 1);\n                    }\n                }\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                if (currentNode) {\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                }\n                //check if last tag of nested tag was unpaired tag\n                const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n                if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n                    throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n                }\n                let propIndex = 0;\n                if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n                    propIndex = jPath.lastIndexOf(\".\", jPath.lastIndexOf(\".\") - 1);\n                    this.tagsNodeStack.pop();\n                } else {\n                    propIndex = jPath.lastIndexOf(\".\");\n                }\n                jPath = jPath.substring(0, propIndex);\n                currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope\n                textData = \"\";\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                let tagData = readTagExp(xmlData, i, false, \"?>\");\n                if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n                    const childNode = new xmlNode(tagData.tagName);\n                    childNode.add(this.options.textNodeName, \"\");\n                    if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n                    }\n                    this.addChild(currentNode, childNode, jPath);\n                }\n                i = tagData.closeIndex + 1;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n                if (this.options.commentPropName) {\n                    const comment = xmlData.substring(i + 4, endIndex - 2);\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                    currentNode.add(this.options.commentPropName, [\n                        {\n                            [this.options.textNodeName]: comment\n                        }\n                    ]);\n                }\n                i = endIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"!D\") {\n                const result = readDocType(xmlData, i);\n                this.docTypeEntities = result.entities;\n                i = result.i;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n                const tagExp = xmlData.substring(i + 9, closeIndex);\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                //cdata should be set even if it is 0 length string\n                if (this.options.cdataPropName) {\n                    // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n                    // if(!val) val = \"\";\n                    currentNode.add(this.options.cdataPropName, [\n                        {\n                            [this.options.textNodeName]: tagExp\n                        }\n                    ]);\n                } else {\n                    let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n                    if (val == undefined) val = \"\";\n                    currentNode.add(this.options.textNodeName, val);\n                }\n                i = closeIndex + 2;\n            } else {\n                let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n                let tagName = result.tagName;\n                let tagExp = result.tagExp;\n                let attrExpPresent = result.attrExpPresent;\n                let closeIndex = result.closeIndex;\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                //save text as child node\n                if (currentNode && textData) {\n                    if (currentNode.tagname !== \"!xml\") {\n                        //when nested tag is found\n                        textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n                    }\n                }\n                //check if last tag was unpaired tag\n                const lastTag = currentNode;\n                if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n                    currentNode = this.tagsNodeStack.pop();\n                    jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n                }\n                if (tagName !== xmlObj.tagname) {\n                    jPath += jPath ? \".\" + tagName : tagName;\n                }\n                if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n                    let tagContent = \"\";\n                    //self-closing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        i = result.closeIndex;\n                    } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n                        i = result.closeIndex;\n                    } else {\n                        //read until closing tag is found\n                        const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\n                        if (!result) throw new Error(`Unexpected end of ${tagName}`);\n                        i = result.i;\n                        tagContent = result.tagContent;\n                    }\n                    const childNode = new xmlNode(tagName);\n                    if (tagName !== tagExp && attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                    }\n                    if (tagContent) {\n                        tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n                    }\n                    jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    childNode.add(this.options.textNodeName, tagContent);\n                    this.addChild(currentNode, childNode, jPath);\n                } else {\n                    //selfClosing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        if (tagName[tagName.length - 1] === \"/\") {\n                            tagName = tagName.substr(0, tagName.length - 1);\n                            tagExp = tagName;\n                        } else {\n                            tagExp = tagExp.substr(0, tagExp.length - 1);\n                        }\n                        if (this.options.transformTagName) {\n                            tagName = this.options.transformTagName(tagName);\n                        }\n                        const childNode = new xmlNode(tagName);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath);\n                        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    } else {\n                        const childNode = new xmlNode(tagName);\n                        this.tagsNodeStack.push(currentNode);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath);\n                        currentNode = childNode;\n                    }\n                    textData = \"\";\n                    i = closeIndex;\n                }\n            }\n        } else {\n            textData += xmlData[i];\n        }\n    }\n    return xmlObj.child;\n};\nfunction addChild(currentNode, childNode, jPath) {\n    const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n    if (result === false) {} else if (typeof result === \"string\") {\n        childNode.tagname = result;\n        currentNode.addChild(childNode);\n    } else {\n        currentNode.addChild(childNode);\n    }\n}\nconst replaceEntitiesValue = function(val) {\n    if (this.options.processEntities) {\n        for(let entityName in this.docTypeEntities){\n            const entity = this.docTypeEntities[entityName];\n            val = val.replace(entity.regx, entity.val);\n        }\n        for(let entityName in this.lastEntities){\n            const entity = this.lastEntities[entityName];\n            val = val.replace(entity.regex, entity.val);\n        }\n        if (this.options.htmlEntities) {\n            for(let entityName in this.htmlEntities){\n                const entity = this.htmlEntities[entityName];\n                val = val.replace(entity.regex, entity.val);\n            }\n        }\n        val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n    }\n    return val;\n};\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n    if (textData) {\n        if (isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;\n        textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n        if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n        textData = \"\";\n    }\n    return textData;\n}\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */ function isItStopNode(stopNodes, jPath, currentTagName) {\n    const allNodesExp = \"*.\" + currentTagName;\n    for(const stopNodePath in stopNodes){\n        const stopNodeExp = stopNodes[stopNodePath];\n        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n    }\n    return false;\n}\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */ function tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n    let attrBoundary;\n    let tagExp = \"\";\n    for(let index = i; index < xmlData.length; index++){\n        let ch = xmlData[index];\n        if (attrBoundary) {\n            if (ch === attrBoundary) attrBoundary = \"\"; //reset\n        } else if (ch === '\"' || ch === \"'\") {\n            attrBoundary = ch;\n        } else if (ch === closingChar[0]) {\n            if (closingChar[1]) {\n                if (xmlData[index + 1] === closingChar[1]) {\n                    return {\n                        data: tagExp,\n                        index: index\n                    };\n                }\n            } else {\n                return {\n                    data: tagExp,\n                    index: index\n                };\n            }\n        } else if (ch === \"\t\") {\n            ch = \" \";\n        }\n        tagExp += ch;\n    }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n    const closingIndex = xmlData.indexOf(str, i);\n    if (closingIndex === -1) {\n        throw new Error(errMsg);\n    } else {\n        return closingIndex + str.length - 1;\n    }\n}\nfunction readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n    if (!result) return;\n    let tagExp = result.data;\n    const closeIndex = result.index;\n    const separatorIndex = tagExp.search(/\\s/);\n    let tagName = tagExp;\n    let attrExpPresent = true;\n    if (separatorIndex !== -1) {\n        tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, \"\");\n        tagExp = tagExp.substr(separatorIndex + 1);\n    }\n    if (removeNSPrefix) {\n        const colonIndex = tagName.indexOf(\":\");\n        if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n        }\n    }\n    return {\n        tagName: tagName,\n        tagExp: tagExp,\n        closeIndex: closeIndex,\n        attrExpPresent: attrExpPresent\n    };\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */ function readStopNodeData(xmlData, tagName, i) {\n    const startIndex = i;\n    // Starting at 1 since we already have an open tag\n    let openTagCount = 1;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\") {\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n                let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (closeTagName === tagName) {\n                    openTagCount--;\n                    if (openTagCount === 0) {\n                        return {\n                            tagContent: xmlData.substring(startIndex, i),\n                            i: closeIndex\n                        };\n                    }\n                }\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n                i = closeIndex;\n            } else {\n                const tagData = readTagExp(xmlData, i, \">\");\n                if (tagData) {\n                    const openTagName = tagData && tagData.tagName;\n                    if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n                        openTagCount++;\n                    }\n                    i = tagData.closeIndex;\n                }\n            }\n        }\n    } //end for loop\n}\nfunction parseValue(val, shouldParse, options) {\n    if (shouldParse && typeof val === \"string\") {\n        //console.log(options)\n        const newval = val.trim();\n        if (newval === \"true\") return true;\n        else if (newval === \"false\") return false;\n        else return toNumber(val, options);\n    } else {\n        if (util.isExist(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\nmodule.exports = OrderedObjParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3JkZXJlZE9ialBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFFWixNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNyQixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyx5SUFBaUI7QUFDN0MsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMseUZBQVE7QUFFakMsTUFBTUksT0FDSix3RkFDQ0MsT0FBTyxDQUFDLFNBQVNOLEtBQUtPLFVBQVU7QUFFbkMsOEZBQThGO0FBQzlGLG9IQUFvSDtBQUVwSCxNQUFNQztJQUNKQyxZQUFZQyxPQUFPLENBQUM7UUFDbEIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNDLGVBQWUsR0FBRyxDQUFDO1FBQ3hCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1lBQ2xCLFFBQVM7Z0JBQUVDLE9BQU87Z0JBQXNCQyxLQUFNO1lBQUc7WUFDakQsTUFBTztnQkFBRUQsT0FBTztnQkFBb0JDLEtBQU07WUFBRztZQUM3QyxNQUFPO2dCQUFFRCxPQUFPO2dCQUFvQkMsS0FBTTtZQUFHO1lBQzdDLFFBQVM7Z0JBQUVELE9BQU87Z0JBQXNCQyxLQUFNO1lBQUk7UUFDcEQ7UUFDQSxJQUFJLENBQUNDLFNBQVMsR0FBRztZQUFFRixPQUFPO1lBQXFCQyxLQUFNO1FBQUc7UUFDeEQsSUFBSSxDQUFDRSxZQUFZLEdBQUc7WUFDbEIsU0FBUztnQkFBRUgsT0FBTztnQkFBa0JDLEtBQUs7WUFBSTtZQUM3Qyw2Q0FBNkM7WUFDN0MsNkNBQTZDO1lBQzdDLCtDQUErQztZQUMvQyxrREFBa0Q7WUFDbEQsaURBQWlEO1lBQ2pELFFBQVM7Z0JBQUVELE9BQU87Z0JBQWtCQyxLQUFLO1lBQUk7WUFDN0MsU0FBVTtnQkFBRUQsT0FBTztnQkFBbUJDLEtBQUs7WUFBSTtZQUMvQyxPQUFRO2dCQUFFRCxPQUFPO2dCQUFpQkMsS0FBSztZQUFJO1lBQzNDLFFBQVM7Z0JBQUVELE9BQU87Z0JBQW1CQyxLQUFLO1lBQUk7WUFDOUMsYUFBYztnQkFBRUQsT0FBTztnQkFBa0JDLEtBQUs7WUFBSTtZQUNsRCxPQUFRO2dCQUFFRCxPQUFPO2dCQUFpQkMsS0FBSztZQUFJO1lBQzNDLE9BQVE7Z0JBQUVELE9BQU87Z0JBQWtCQyxLQUFLO1lBQUk7UUFDOUM7UUFDQSxJQUFJLENBQUNHLG1CQUFtQixHQUFHQTtRQUMzQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdBO1FBQzFCLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLG9CQUFvQixHQUFHQTtRQUM1QixJQUFJLENBQUNDLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNDLG1CQUFtQixHQUFHQTtRQUMzQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDbEI7QUFFRjtBQUVBLFNBQVNULG9CQUFvQlUsZ0JBQWdCO0lBQzNDLE1BQU1DLFVBQVVDLE9BQU9DLElBQUksQ0FBQ0g7SUFDNUIsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlILFFBQVFJLE1BQU0sRUFBRUQsSUFBSztRQUN2QyxNQUFNRSxNQUFNTCxPQUFPLENBQUNHLEVBQUU7UUFDdEIsSUFBSSxDQUFDbkIsWUFBWSxDQUFDcUIsSUFBSSxHQUFHO1lBQ3RCcEIsT0FBTyxJQUFJcUIsT0FBTyxNQUFJRCxNQUFJLEtBQUk7WUFDOUJuQixLQUFNYSxnQkFBZ0IsQ0FBQ00sSUFBSTtRQUM5QjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNkLGNBQWNMLEdBQUcsRUFBRXFCLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsVUFBVSxFQUFFQyxjQUFjO0lBQzdGLElBQUkxQixRQUFRMkIsV0FBVztRQUNyQixJQUFJLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ2tDLFVBQVUsSUFBSSxDQUFDTCxVQUFVO1lBQ3hDdkIsTUFBTUEsSUFBSTZCLElBQUk7UUFDaEI7UUFDQSxJQUFHN0IsSUFBSWtCLE1BQU0sR0FBRyxHQUFFO1lBQ2hCLElBQUcsQ0FBQ1EsZ0JBQWdCMUIsTUFBTSxJQUFJLENBQUNTLG9CQUFvQixDQUFDVDtZQUVwRCxNQUFNOEIsU0FBUyxJQUFJLENBQUNwQyxPQUFPLENBQUNxQyxpQkFBaUIsQ0FBQ1YsU0FBU3JCLEtBQUtzQixPQUFPRSxlQUFlQztZQUNsRixJQUFHSyxXQUFXLFFBQVFBLFdBQVdILFdBQVU7Z0JBQ3pDLGFBQWE7Z0JBQ2IsT0FBTzNCO1lBQ1QsT0FBTSxJQUFHLE9BQU84QixXQUFXLE9BQU85QixPQUFPOEIsV0FBVzlCLEtBQUk7Z0JBQ3RELFdBQVc7Z0JBQ1gsT0FBTzhCO1lBQ1QsT0FBTSxJQUFHLElBQUksQ0FBQ3BDLE9BQU8sQ0FBQ2tDLFVBQVUsRUFBQztnQkFDL0IsT0FBT0ksV0FBV2hDLEtBQUssSUFBSSxDQUFDTixPQUFPLENBQUN1QyxhQUFhLEVBQUUsSUFBSSxDQUFDdkMsT0FBTyxDQUFDd0Msa0JBQWtCO1lBQ3BGLE9BQUs7Z0JBQ0gsTUFBTUMsYUFBYW5DLElBQUk2QixJQUFJO2dCQUMzQixJQUFHTSxlQUFlbkMsS0FBSTtvQkFDcEIsT0FBT2dDLFdBQVdoQyxLQUFLLElBQUksQ0FBQ04sT0FBTyxDQUFDdUMsYUFBYSxFQUFFLElBQUksQ0FBQ3ZDLE9BQU8sQ0FBQ3dDLGtCQUFrQjtnQkFDcEYsT0FBSztvQkFDSCxPQUFPbEM7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNNLGlCQUFpQjhCLE9BQU87SUFDL0IsSUFBSSxJQUFJLENBQUMxQyxPQUFPLENBQUMyQyxjQUFjLEVBQUU7UUFDL0IsTUFBTUMsT0FBT0YsUUFBUUcsS0FBSyxDQUFDO1FBQzNCLE1BQU1DLFNBQVNKLFFBQVFLLE1BQU0sQ0FBQyxPQUFPLE1BQU0sTUFBTTtRQUNqRCxJQUFJSCxJQUFJLENBQUMsRUFBRSxLQUFLLFNBQVM7WUFDdkIsT0FBTztRQUNUO1FBQ0EsSUFBSUEsS0FBS3BCLE1BQU0sS0FBSyxHQUFHO1lBQ3JCa0IsVUFBVUksU0FBU0YsSUFBSSxDQUFDLEVBQUU7UUFDNUI7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQSxrQ0FBa0M7QUFDbEMsc0ZBQXNGO0FBQ3RGLE1BQU1NLFlBQVksSUFBSXRCLE9BQU8sZ0RBQWdEO0FBRTdFLFNBQVNiLG1CQUFtQm9DLE9BQU8sRUFBRXJCLEtBQUssRUFBRUQsT0FBTztJQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDM0IsT0FBTyxDQUFDa0QsZ0JBQWdCLElBQUksT0FBT0QsWUFBWSxVQUFVO1FBQ2pFLDRDQUE0QztRQUM1QyxzQ0FBc0M7UUFFdEMsTUFBTUUsVUFBVTdELEtBQUs4RCxhQUFhLENBQUNILFNBQVNEO1FBQzVDLE1BQU1LLE1BQU1GLFFBQVEzQixNQUFNLEVBQUUsc0JBQXNCO1FBQ2xELE1BQU04QixRQUFRLENBQUM7UUFDZixJQUFLLElBQUkvQixJQUFJLEdBQUdBLElBQUk4QixLQUFLOUIsSUFBSztZQUM1QixNQUFNZ0MsV0FBVyxJQUFJLENBQUMzQyxnQkFBZ0IsQ0FBQ3VDLE9BQU8sQ0FBQzVCLEVBQUUsQ0FBQyxFQUFFO1lBQ3BELElBQUlpQyxTQUFTTCxPQUFPLENBQUM1QixFQUFFLENBQUMsRUFBRTtZQUMxQixJQUFJa0MsUUFBUSxJQUFJLENBQUN6RCxPQUFPLENBQUMwRCxtQkFBbUIsR0FBR0g7WUFDL0MsSUFBSUEsU0FBUy9CLE1BQU0sRUFBRTtnQkFDbkIsSUFBSSxJQUFJLENBQUN4QixPQUFPLENBQUMyRCxzQkFBc0IsRUFBRTtvQkFDdkNGLFFBQVEsSUFBSSxDQUFDekQsT0FBTyxDQUFDMkQsc0JBQXNCLENBQUNGO2dCQUM5QztnQkFDQSxJQUFHQSxVQUFVLGFBQWFBLFFBQVM7Z0JBQ25DLElBQUlELFdBQVd2QixXQUFXO29CQUN4QixJQUFJLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ2tDLFVBQVUsRUFBRTt3QkFDM0JzQixTQUFTQSxPQUFPckIsSUFBSTtvQkFDdEI7b0JBQ0FxQixTQUFTLElBQUksQ0FBQ3pDLG9CQUFvQixDQUFDeUM7b0JBQ25DLE1BQU1JLFNBQVMsSUFBSSxDQUFDNUQsT0FBTyxDQUFDNkQsdUJBQXVCLENBQUNOLFVBQVVDLFFBQVE1QjtvQkFDdEUsSUFBR2dDLFdBQVcsUUFBUUEsV0FBVzNCLFdBQVU7d0JBQ3pDLGFBQWE7d0JBQ2JxQixLQUFLLENBQUNHLE1BQU0sR0FBR0Q7b0JBQ2pCLE9BQU0sSUFBRyxPQUFPSSxXQUFXLE9BQU9KLFVBQVVJLFdBQVdKLFFBQU87d0JBQzVELFdBQVc7d0JBQ1hGLEtBQUssQ0FBQ0csTUFBTSxHQUFHRztvQkFDakIsT0FBSzt3QkFDSCxPQUFPO3dCQUNQTixLQUFLLENBQUNHLE1BQU0sR0FBR25CLFdBQ2JrQixRQUNBLElBQUksQ0FBQ3hELE9BQU8sQ0FBQzhELG1CQUFtQixFQUNoQyxJQUFJLENBQUM5RCxPQUFPLENBQUN3QyxrQkFBa0I7b0JBRW5DO2dCQUNGLE9BQU8sSUFBSSxJQUFJLENBQUN4QyxPQUFPLENBQUMrRCxzQkFBc0IsRUFBRTtvQkFDOUNULEtBQUssQ0FBQ0csTUFBTSxHQUFHO2dCQUNqQjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNwQyxPQUFPQyxJQUFJLENBQUNnQyxPQUFPOUIsTUFBTSxFQUFFO1lBQzlCO1FBQ0Y7UUFDQSxJQUFJLElBQUksQ0FBQ3hCLE9BQU8sQ0FBQ2dFLG1CQUFtQixFQUFFO1lBQ3BDLE1BQU1DLGlCQUFpQixDQUFDO1lBQ3hCQSxjQUFjLENBQUMsSUFBSSxDQUFDakUsT0FBTyxDQUFDZ0UsbUJBQW1CLENBQUMsR0FBR1Y7WUFDbkQsT0FBT1c7UUFDVDtRQUNBLE9BQU9YO0lBQ1Q7QUFDRjtBQUVBLE1BQU01QyxXQUFXLFNBQVN3RCxPQUFPO0lBQy9CQSxVQUFVQSxRQUFRdEUsT0FBTyxDQUFDLFVBQVUsT0FBTyx3QkFBd0I7SUFDbkUsTUFBTXVFLFNBQVMsSUFBSTNFLFFBQVE7SUFDM0IsSUFBSVMsY0FBY2tFO0lBQ2xCLElBQUlDLFdBQVc7SUFDZixJQUFJeEMsUUFBUTtJQUNaLElBQUksSUFBSUwsSUFBRSxHQUFHQSxJQUFHMkMsUUFBUTFDLE1BQU0sRUFBRUQsSUFBSTtRQUNsQyxNQUFNOEMsS0FBS0gsT0FBTyxDQUFDM0MsRUFBRTtRQUNyQixJQUFHOEMsT0FBTyxLQUFJO1lBQ1oseUJBQXlCO1lBQ3pCLHVDQUF1QztZQUN2QyxJQUFJSCxPQUFPLENBQUMzQyxJQUFFLEVBQUUsS0FBSyxLQUFLO2dCQUN4QixNQUFNK0MsYUFBYUMsaUJBQWlCTCxTQUFTLEtBQUszQyxHQUFHO2dCQUNyRCxJQUFJSSxVQUFVdUMsUUFBUU0sU0FBUyxDQUFDakQsSUFBRSxHQUFFK0MsWUFBWW5DLElBQUk7Z0JBRXBELElBQUcsSUFBSSxDQUFDbkMsT0FBTyxDQUFDMkMsY0FBYyxFQUFDO29CQUM3QixNQUFNOEIsYUFBYTlDLFFBQVErQyxPQUFPLENBQUM7b0JBQ25DLElBQUdELGVBQWUsQ0FBQyxHQUFFO3dCQUNuQjlDLFVBQVVBLFFBQVFnRCxNQUFNLENBQUNGLGFBQVc7b0JBQ3RDO2dCQUNGO2dCQUVBLElBQUcsSUFBSSxDQUFDekUsT0FBTyxDQUFDNEUsZ0JBQWdCLEVBQUU7b0JBQ2hDakQsVUFBVSxJQUFJLENBQUMzQixPQUFPLENBQUM0RSxnQkFBZ0IsQ0FBQ2pEO2dCQUMxQztnQkFFQSxJQUFHMUIsYUFBWTtvQkFDYm1FLFdBQVcsSUFBSSxDQUFDbkQsbUJBQW1CLENBQUNtRCxVQUFVbkUsYUFBYTJCO2dCQUM3RDtnQkFFQSxrREFBa0Q7Z0JBQ2xELE1BQU1pRCxjQUFjakQsTUFBTTRDLFNBQVMsQ0FBQzVDLE1BQU1rRCxXQUFXLENBQUMsT0FBSztnQkFDM0QsSUFBR25ELFdBQVcsSUFBSSxDQUFDM0IsT0FBTyxDQUFDK0UsWUFBWSxDQUFDTCxPQUFPLENBQUMvQyxhQUFhLENBQUMsR0FBRztvQkFDL0QsTUFBTSxJQUFJcUQsTUFBTSxDQUFDLCtDQUErQyxFQUFFckQsUUFBUSxDQUFDLENBQUM7Z0JBQzlFO2dCQUNBLElBQUlzRCxZQUFZO2dCQUNoQixJQUFHSixlQUFlLElBQUksQ0FBQzdFLE9BQU8sQ0FBQytFLFlBQVksQ0FBQ0wsT0FBTyxDQUFDRyxpQkFBaUIsQ0FBQyxHQUFHO29CQUN2RUksWUFBWXJELE1BQU1rRCxXQUFXLENBQUMsS0FBS2xELE1BQU1rRCxXQUFXLENBQUMsT0FBSztvQkFDMUQsSUFBSSxDQUFDNUUsYUFBYSxDQUFDZ0YsR0FBRztnQkFDeEIsT0FBSztvQkFDSEQsWUFBWXJELE1BQU1rRCxXQUFXLENBQUM7Z0JBQ2hDO2dCQUNBbEQsUUFBUUEsTUFBTTRDLFNBQVMsQ0FBQyxHQUFHUztnQkFFM0JoRixjQUFjLElBQUksQ0FBQ0MsYUFBYSxDQUFDZ0YsR0FBRyxJQUFHLDJDQUEyQztnQkFDbEZkLFdBQVc7Z0JBQ1g3QyxJQUFJK0M7WUFDTixPQUFPLElBQUlKLE9BQU8sQ0FBQzNDLElBQUUsRUFBRSxLQUFLLEtBQUs7Z0JBRS9CLElBQUk0RCxVQUFVQyxXQUFXbEIsU0FBUTNDLEdBQUcsT0FBTztnQkFDM0MsSUFBRyxDQUFDNEQsU0FBUyxNQUFNLElBQUlILE1BQU07Z0JBRTdCWixXQUFXLElBQUksQ0FBQ25ELG1CQUFtQixDQUFDbUQsVUFBVW5FLGFBQWEyQjtnQkFDM0QsSUFBSSxJQUFLLENBQUM1QixPQUFPLENBQUNxRixpQkFBaUIsSUFBSUYsUUFBUXhELE9BQU8sS0FBSyxVQUFXLElBQUksQ0FBQzNCLE9BQU8sQ0FBQ3NGLFlBQVksRUFBQyxDQUVoRyxPQUFLO29CQUVILE1BQU1DLFlBQVksSUFBSS9GLFFBQVEyRixRQUFReEQsT0FBTztvQkFDN0M0RCxVQUFVQyxHQUFHLENBQUMsSUFBSSxDQUFDeEYsT0FBTyxDQUFDeUYsWUFBWSxFQUFFO29CQUV6QyxJQUFHTixRQUFReEQsT0FBTyxLQUFLd0QsUUFBUU8sTUFBTSxJQUFJUCxRQUFRUSxjQUFjLEVBQUM7d0JBQzlESixTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzFFLGtCQUFrQixDQUFDc0UsUUFBUU8sTUFBTSxFQUFFOUQsT0FBT3VELFFBQVF4RCxPQUFPO29CQUNsRjtvQkFDQSxJQUFJLENBQUNULFFBQVEsQ0FBQ2pCLGFBQWFzRixXQUFXM0Q7Z0JBRXhDO2dCQUdBTCxJQUFJNEQsUUFBUWIsVUFBVSxHQUFHO1lBQzNCLE9BQU8sSUFBR0osUUFBUVMsTUFBTSxDQUFDcEQsSUFBSSxHQUFHLE9BQU8sT0FBTztnQkFDNUMsTUFBTXFFLFdBQVdyQixpQkFBaUJMLFNBQVMsT0FBTzNDLElBQUUsR0FBRztnQkFDdkQsSUFBRyxJQUFJLENBQUN2QixPQUFPLENBQUM2RixlQUFlLEVBQUM7b0JBQzlCLE1BQU1DLFVBQVU1QixRQUFRTSxTQUFTLENBQUNqRCxJQUFJLEdBQUdxRSxXQUFXO29CQUVwRHhCLFdBQVcsSUFBSSxDQUFDbkQsbUJBQW1CLENBQUNtRCxVQUFVbkUsYUFBYTJCO29CQUUzRDNCLFlBQVl1RixHQUFHLENBQUMsSUFBSSxDQUFDeEYsT0FBTyxDQUFDNkYsZUFBZSxFQUFFO3dCQUFFOzRCQUFFLENBQUMsSUFBSSxDQUFDN0YsT0FBTyxDQUFDeUYsWUFBWSxDQUFDLEVBQUdLO3dCQUFRO3FCQUFHO2dCQUM3RjtnQkFDQXZFLElBQUlxRTtZQUNOLE9BQU8sSUFBSTFCLFFBQVFTLE1BQU0sQ0FBQ3BELElBQUksR0FBRyxPQUFPLE1BQU07Z0JBQzVDLE1BQU13RSxTQUFTdEcsWUFBWXlFLFNBQVMzQztnQkFDcEMsSUFBSSxDQUFDcEIsZUFBZSxHQUFHNEYsT0FBT0MsUUFBUTtnQkFDdEN6RSxJQUFJd0UsT0FBT3hFLENBQUM7WUFDZCxPQUFNLElBQUcyQyxRQUFRUyxNQUFNLENBQUNwRCxJQUFJLEdBQUcsT0FBTyxNQUFNO2dCQUMxQyxNQUFNK0MsYUFBYUMsaUJBQWlCTCxTQUFTLE9BQU8zQyxHQUFHLDBCQUEwQjtnQkFDakYsTUFBTW1FLFNBQVN4QixRQUFRTSxTQUFTLENBQUNqRCxJQUFJLEdBQUUrQztnQkFFdkNGLFdBQVcsSUFBSSxDQUFDbkQsbUJBQW1CLENBQUNtRCxVQUFVbkUsYUFBYTJCO2dCQUUzRCxtREFBbUQ7Z0JBQ25ELElBQUcsSUFBSSxDQUFDNUIsT0FBTyxDQUFDaUcsYUFBYSxFQUFDO29CQUM1QixpSUFBaUk7b0JBQ2pJLHFCQUFxQjtvQkFDckJoRyxZQUFZdUYsR0FBRyxDQUFDLElBQUksQ0FBQ3hGLE9BQU8sQ0FBQ2lHLGFBQWEsRUFBRTt3QkFBRTs0QkFBRSxDQUFDLElBQUksQ0FBQ2pHLE9BQU8sQ0FBQ3lGLFlBQVksQ0FBQyxFQUFHQzt3QkFBTztxQkFBRztnQkFDMUYsT0FBSztvQkFDSCxJQUFJcEYsTUFBTSxJQUFJLENBQUNLLGFBQWEsQ0FBQytFLFFBQVF6RixZQUFZeUMsT0FBTyxFQUFFZCxPQUFPLE1BQU0sT0FBTztvQkFDOUUsSUFBR3RCLE9BQU8yQixXQUFXM0IsTUFBTTtvQkFDM0JMLFlBQVl1RixHQUFHLENBQUMsSUFBSSxDQUFDeEYsT0FBTyxDQUFDeUYsWUFBWSxFQUFFbkY7Z0JBQzdDO2dCQUVBaUIsSUFBSStDLGFBQWE7WUFDbkIsT0FBTTtnQkFDSixJQUFJeUIsU0FBU1gsV0FBV2xCLFNBQVEzQyxHQUFHLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQzJDLGNBQWM7Z0JBQzlELElBQUloQixVQUFTb0UsT0FBT3BFLE9BQU87Z0JBQzNCLElBQUkrRCxTQUFTSyxPQUFPTCxNQUFNO2dCQUMxQixJQUFJQyxpQkFBaUJJLE9BQU9KLGNBQWM7Z0JBQzFDLElBQUlyQixhQUFheUIsT0FBT3pCLFVBQVU7Z0JBRWxDLElBQUksSUFBSSxDQUFDdEUsT0FBTyxDQUFDNEUsZ0JBQWdCLEVBQUU7b0JBQ2pDakQsVUFBVSxJQUFJLENBQUMzQixPQUFPLENBQUM0RSxnQkFBZ0IsQ0FBQ2pEO2dCQUMxQztnQkFFQSx5QkFBeUI7Z0JBQ3pCLElBQUkxQixlQUFlbUUsVUFBVTtvQkFDM0IsSUFBR25FLFlBQVl5QyxPQUFPLEtBQUssUUFBTzt3QkFDaEMsMEJBQTBCO3dCQUMxQjBCLFdBQVcsSUFBSSxDQUFDbkQsbUJBQW1CLENBQUNtRCxVQUFVbkUsYUFBYTJCLE9BQU87b0JBQ3BFO2dCQUNGO2dCQUVBLG9DQUFvQztnQkFDcEMsTUFBTXNFLFVBQVVqRztnQkFDaEIsSUFBR2lHLFdBQVcsSUFBSSxDQUFDbEcsT0FBTyxDQUFDK0UsWUFBWSxDQUFDTCxPQUFPLENBQUN3QixRQUFReEQsT0FBTyxNQUFNLENBQUMsR0FBRztvQkFDdkV6QyxjQUFjLElBQUksQ0FBQ0MsYUFBYSxDQUFDZ0YsR0FBRztvQkFDcEN0RCxRQUFRQSxNQUFNNEMsU0FBUyxDQUFDLEdBQUc1QyxNQUFNa0QsV0FBVyxDQUFDO2dCQUMvQztnQkFDQSxJQUFHbkQsWUFBWXdDLE9BQU96QixPQUFPLEVBQUM7b0JBQzVCZCxTQUFTQSxRQUFRLE1BQU1ELFVBQVVBO2dCQUNuQztnQkFDQSxJQUFJLElBQUksQ0FBQ2IsWUFBWSxDQUFDLElBQUksQ0FBQ2QsT0FBTyxDQUFDbUcsU0FBUyxFQUFFdkUsT0FBT0QsVUFBVTtvQkFDN0QsSUFBSXlFLGFBQWE7b0JBQ2pCLGtCQUFrQjtvQkFDbEIsSUFBR1YsT0FBT2xFLE1BQU0sR0FBRyxLQUFLa0UsT0FBT1osV0FBVyxDQUFDLFNBQVNZLE9BQU9sRSxNQUFNLEdBQUcsR0FBRTt3QkFDcEVELElBQUl3RSxPQUFPekIsVUFBVTtvQkFDdkIsT0FFSyxJQUFHLElBQUksQ0FBQ3RFLE9BQU8sQ0FBQytFLFlBQVksQ0FBQ0wsT0FBTyxDQUFDL0MsYUFBYSxDQUFDLEdBQUU7d0JBQ3hESixJQUFJd0UsT0FBT3pCLFVBQVU7b0JBQ3ZCLE9BRUk7d0JBQ0YsaUNBQWlDO3dCQUNqQyxNQUFNeUIsU0FBUyxJQUFJLENBQUMvRSxnQkFBZ0IsQ0FBQ2tELFNBQVN2QyxTQUFTMkMsYUFBYTt3QkFDcEUsSUFBRyxDQUFDeUIsUUFBUSxNQUFNLElBQUlmLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRXJELFFBQVEsQ0FBQzt3QkFDMURKLElBQUl3RSxPQUFPeEUsQ0FBQzt3QkFDWjZFLGFBQWFMLE9BQU9LLFVBQVU7b0JBQ2hDO29CQUVBLE1BQU1iLFlBQVksSUFBSS9GLFFBQVFtQztvQkFDOUIsSUFBR0EsWUFBWStELFVBQVVDLGdCQUFlO3dCQUN0Q0osU0FBUyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMxRSxrQkFBa0IsQ0FBQzZFLFFBQVE5RCxPQUFPRDtvQkFDM0Q7b0JBQ0EsSUFBR3lFLFlBQVk7d0JBQ2JBLGFBQWEsSUFBSSxDQUFDekYsYUFBYSxDQUFDeUYsWUFBWXpFLFNBQVNDLE9BQU8sTUFBTStELGdCQUFnQixNQUFNO29CQUMxRjtvQkFFQS9ELFFBQVFBLE1BQU0rQyxNQUFNLENBQUMsR0FBRy9DLE1BQU1rRCxXQUFXLENBQUM7b0JBQzFDUyxVQUFVQyxHQUFHLENBQUMsSUFBSSxDQUFDeEYsT0FBTyxDQUFDeUYsWUFBWSxFQUFFVztvQkFFekMsSUFBSSxDQUFDbEYsUUFBUSxDQUFDakIsYUFBYXNGLFdBQVczRDtnQkFDeEMsT0FBSztvQkFDWCxpQkFBaUI7b0JBQ1QsSUFBRzhELE9BQU9sRSxNQUFNLEdBQUcsS0FBS2tFLE9BQU9aLFdBQVcsQ0FBQyxTQUFTWSxPQUFPbEUsTUFBTSxHQUFHLEdBQUU7d0JBQ3BFLElBQUdHLE9BQU8sQ0FBQ0EsUUFBUUgsTUFBTSxHQUFHLEVBQUUsS0FBSyxLQUFJOzRCQUNyQ0csVUFBVUEsUUFBUWdELE1BQU0sQ0FBQyxHQUFHaEQsUUFBUUgsTUFBTSxHQUFHOzRCQUM3Q2tFLFNBQVMvRDt3QkFDWCxPQUFLOzRCQUNIK0QsU0FBU0EsT0FBT2YsTUFBTSxDQUFDLEdBQUdlLE9BQU9sRSxNQUFNLEdBQUc7d0JBQzVDO3dCQUVBLElBQUcsSUFBSSxDQUFDeEIsT0FBTyxDQUFDNEUsZ0JBQWdCLEVBQUU7NEJBQ2hDakQsVUFBVSxJQUFJLENBQUMzQixPQUFPLENBQUM0RSxnQkFBZ0IsQ0FBQ2pEO3dCQUMxQzt3QkFFQSxNQUFNNEQsWUFBWSxJQUFJL0YsUUFBUW1DO3dCQUM5QixJQUFHQSxZQUFZK0QsVUFBVUMsZ0JBQWU7NEJBQ3RDSixTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzFFLGtCQUFrQixDQUFDNkUsUUFBUTlELE9BQU9EO3dCQUMzRDt3QkFDQSxJQUFJLENBQUNULFFBQVEsQ0FBQ2pCLGFBQWFzRixXQUFXM0Q7d0JBQ3RDQSxRQUFRQSxNQUFNK0MsTUFBTSxDQUFDLEdBQUcvQyxNQUFNa0QsV0FBVyxDQUFDO29CQUM1QyxPQUVJO3dCQUNGLE1BQU1TLFlBQVksSUFBSS9GLFFBQVNtQzt3QkFDL0IsSUFBSSxDQUFDekIsYUFBYSxDQUFDbUcsSUFBSSxDQUFDcEc7d0JBRXhCLElBQUcwQixZQUFZK0QsVUFBVUMsZ0JBQWU7NEJBQ3RDSixTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzFFLGtCQUFrQixDQUFDNkUsUUFBUTlELE9BQU9EO3dCQUMzRDt3QkFDQSxJQUFJLENBQUNULFFBQVEsQ0FBQ2pCLGFBQWFzRixXQUFXM0Q7d0JBQ3RDM0IsY0FBY3NGO29CQUNoQjtvQkFDQW5CLFdBQVc7b0JBQ1g3QyxJQUFJK0M7Z0JBQ047WUFDRjtRQUNGLE9BQUs7WUFDSEYsWUFBWUYsT0FBTyxDQUFDM0MsRUFBRTtRQUN4QjtJQUNGO0lBQ0EsT0FBTzRDLE9BQU9tQyxLQUFLO0FBQ3JCO0FBRUEsU0FBU3BGLFNBQVNqQixXQUFXLEVBQUVzRixTQUFTLEVBQUUzRCxLQUFLO0lBQzdDLE1BQU1tRSxTQUFTLElBQUksQ0FBQy9GLE9BQU8sQ0FBQ3VHLFNBQVMsQ0FBQ2hCLFVBQVU3QyxPQUFPLEVBQUVkLE9BQU8yRCxTQUFTLENBQUMsS0FBSztJQUMvRSxJQUFHUSxXQUFXLE9BQU0sQ0FDcEIsT0FBTSxJQUFHLE9BQU9BLFdBQVcsVUFBUztRQUNsQ1IsVUFBVTdDLE9BQU8sR0FBR3FEO1FBQ3BCOUYsWUFBWWlCLFFBQVEsQ0FBQ3FFO0lBQ3ZCLE9BQUs7UUFDSHRGLFlBQVlpQixRQUFRLENBQUNxRTtJQUN2QjtBQUNGO0FBRUEsTUFBTXhFLHVCQUF1QixTQUFTVCxHQUFHO0lBRXZDLElBQUcsSUFBSSxDQUFDTixPQUFPLENBQUN3RyxlQUFlLEVBQUM7UUFDOUIsSUFBSSxJQUFJQyxjQUFjLElBQUksQ0FBQ3RHLGVBQWUsQ0FBQztZQUN6QyxNQUFNdUcsU0FBUyxJQUFJLENBQUN2RyxlQUFlLENBQUNzRyxXQUFXO1lBQy9DbkcsTUFBTUEsSUFBSVYsT0FBTyxDQUFFOEcsT0FBTy9HLElBQUksRUFBRStHLE9BQU9wRyxHQUFHO1FBQzVDO1FBQ0EsSUFBSSxJQUFJbUcsY0FBYyxJQUFJLENBQUNyRyxZQUFZLENBQUM7WUFDdEMsTUFBTXNHLFNBQVMsSUFBSSxDQUFDdEcsWUFBWSxDQUFDcUcsV0FBVztZQUM1Q25HLE1BQU1BLElBQUlWLE9BQU8sQ0FBRThHLE9BQU9yRyxLQUFLLEVBQUVxRyxPQUFPcEcsR0FBRztRQUM3QztRQUNBLElBQUcsSUFBSSxDQUFDTixPQUFPLENBQUNRLFlBQVksRUFBQztZQUMzQixJQUFJLElBQUlpRyxjQUFjLElBQUksQ0FBQ2pHLFlBQVksQ0FBQztnQkFDdEMsTUFBTWtHLFNBQVMsSUFBSSxDQUFDbEcsWUFBWSxDQUFDaUcsV0FBVztnQkFDNUNuRyxNQUFNQSxJQUFJVixPQUFPLENBQUU4RyxPQUFPckcsS0FBSyxFQUFFcUcsT0FBT3BHLEdBQUc7WUFDN0M7UUFDRjtRQUNBQSxNQUFNQSxJQUFJVixPQUFPLENBQUUsSUFBSSxDQUFDVyxTQUFTLENBQUNGLEtBQUssRUFBRSxJQUFJLENBQUNFLFNBQVMsQ0FBQ0QsR0FBRztJQUM3RDtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTVyxvQkFBb0JtRCxRQUFRLEVBQUVuRSxXQUFXLEVBQUUyQixLQUFLLEVBQUVHLFVBQVU7SUFDbkUsSUFBSXFDLFVBQVU7UUFDWixJQUFHckMsZUFBZUUsV0FBV0YsYUFBYVYsT0FBT0MsSUFBSSxDQUFDckIsWUFBWXFHLEtBQUssRUFBRTlFLE1BQU0sS0FBSztRQUVwRjRDLFdBQVcsSUFBSSxDQUFDekQsYUFBYSxDQUFDeUQsVUFDNUJuRSxZQUFZeUMsT0FBTyxFQUNuQmQsT0FDQSxPQUNBM0IsV0FBVyxDQUFDLEtBQUssR0FBR29CLE9BQU9DLElBQUksQ0FBQ3JCLFdBQVcsQ0FBQyxLQUFLLEVBQUV1QixNQUFNLEtBQUssSUFBSSxPQUNsRU87UUFFRixJQUFJcUMsYUFBYW5DLGFBQWFtQyxhQUFhLElBQ3pDbkUsWUFBWXVGLEdBQUcsQ0FBQyxJQUFJLENBQUN4RixPQUFPLENBQUN5RixZQUFZLEVBQUVyQjtRQUM3Q0EsV0FBVztJQUNiO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLHVDQUF1QztBQUN2Qzs7Ozs7Q0FLQyxHQUNELFNBQVN0RCxhQUFhcUYsU0FBUyxFQUFFdkUsS0FBSyxFQUFFK0UsY0FBYztJQUNwRCxNQUFNQyxjQUFjLE9BQU9EO0lBQzNCLElBQUssTUFBTUUsZ0JBQWdCVixVQUFXO1FBQ3BDLE1BQU1XLGNBQWNYLFNBQVMsQ0FBQ1UsYUFBYTtRQUMzQyxJQUFJRCxnQkFBZ0JFLGVBQWVsRixVQUFVa0YsYUFBZSxPQUFPO0lBQ3JFO0lBQ0EsT0FBTztBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQyx1QkFBdUI3QyxPQUFPLEVBQUUzQyxDQUFDLEVBQUV5RixjQUFjLEdBQUc7SUFDM0QsSUFBSUM7SUFDSixJQUFJdkIsU0FBUztJQUNiLElBQUssSUFBSXdCLFFBQVEzRixHQUFHMkYsUUFBUWhELFFBQVExQyxNQUFNLEVBQUUwRixRQUFTO1FBQ25ELElBQUk3QyxLQUFLSCxPQUFPLENBQUNnRCxNQUFNO1FBQ3ZCLElBQUlELGNBQWM7WUFDZCxJQUFJNUMsT0FBTzRDLGNBQWNBLGVBQWUsSUFBRyxPQUFPO1FBQ3RELE9BQU8sSUFBSTVDLE9BQU8sT0FBT0EsT0FBTyxLQUFLO1lBQ2pDNEMsZUFBZTVDO1FBQ25CLE9BQU8sSUFBSUEsT0FBTzJDLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDaEMsSUFBR0EsV0FBVyxDQUFDLEVBQUUsRUFBQztnQkFDaEIsSUFBRzlDLE9BQU8sQ0FBQ2dELFFBQVEsRUFBRSxLQUFLRixXQUFXLENBQUMsRUFBRSxFQUFDO29CQUN2QyxPQUFPO3dCQUNMRyxNQUFNekI7d0JBQ053QixPQUFPQTtvQkFDVDtnQkFDRjtZQUNGLE9BQUs7Z0JBQ0gsT0FBTztvQkFDTEMsTUFBTXpCO29CQUNOd0IsT0FBT0E7Z0JBQ1Q7WUFDRjtRQUNGLE9BQU8sSUFBSTdDLE9BQU8sS0FBTTtZQUN0QkEsS0FBSztRQUNQO1FBQ0FxQixVQUFVckI7SUFDWjtBQUNGO0FBRUEsU0FBU0UsaUJBQWlCTCxPQUFPLEVBQUVrRCxHQUFHLEVBQUU3RixDQUFDLEVBQUU4RixNQUFNO0lBQy9DLE1BQU1DLGVBQWVwRCxRQUFRUSxPQUFPLENBQUMwQyxLQUFLN0Y7SUFDMUMsSUFBRytGLGlCQUFpQixDQUFDLEdBQUU7UUFDckIsTUFBTSxJQUFJdEMsTUFBTXFDO0lBQ2xCLE9BQUs7UUFDSCxPQUFPQyxlQUFlRixJQUFJNUYsTUFBTSxHQUFHO0lBQ3JDO0FBQ0Y7QUFFQSxTQUFTNEQsV0FBV2xCLE9BQU8sRUFBQzNDLENBQUMsRUFBRW9CLGNBQWMsRUFBRXFFLGNBQWMsR0FBRztJQUM5RCxNQUFNakIsU0FBU2dCLHVCQUF1QjdDLFNBQVMzQyxJQUFFLEdBQUd5RjtJQUNwRCxJQUFHLENBQUNqQixRQUFRO0lBQ1osSUFBSUwsU0FBU0ssT0FBT29CLElBQUk7SUFDeEIsTUFBTTdDLGFBQWF5QixPQUFPbUIsS0FBSztJQUMvQixNQUFNSyxpQkFBaUI3QixPQUFPOEIsTUFBTSxDQUFDO0lBQ3JDLElBQUk3RixVQUFVK0Q7SUFDZCxJQUFJQyxpQkFBaUI7SUFDckIsSUFBRzRCLG1CQUFtQixDQUFDLEdBQUU7UUFDdkI1RixVQUFVK0QsT0FBT2YsTUFBTSxDQUFDLEdBQUc0QyxnQkFBZ0IzSCxPQUFPLENBQUMsVUFBVTtRQUM3RDhGLFNBQVNBLE9BQU9mLE1BQU0sQ0FBQzRDLGlCQUFpQjtJQUMxQztJQUVBLElBQUc1RSxnQkFBZTtRQUNoQixNQUFNOEIsYUFBYTlDLFFBQVErQyxPQUFPLENBQUM7UUFDbkMsSUFBR0QsZUFBZSxDQUFDLEdBQUU7WUFDbkI5QyxVQUFVQSxRQUFRZ0QsTUFBTSxDQUFDRixhQUFXO1lBQ3BDa0IsaUJBQWlCaEUsWUFBWW9FLE9BQU9vQixJQUFJLENBQUN4QyxNQUFNLENBQUNGLGFBQWE7UUFDL0Q7SUFDRjtJQUVBLE9BQU87UUFDTDlDLFNBQVNBO1FBQ1QrRCxRQUFRQTtRQUNScEIsWUFBWUE7UUFDWnFCLGdCQUFnQkE7SUFDbEI7QUFDRjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBUzNFLGlCQUFpQmtELE9BQU8sRUFBRXZDLE9BQU8sRUFBRUosQ0FBQztJQUMzQyxNQUFNa0csYUFBYWxHO0lBQ25CLGtEQUFrRDtJQUNsRCxJQUFJbUcsZUFBZTtJQUVuQixNQUFPbkcsSUFBSTJDLFFBQVExQyxNQUFNLEVBQUVELElBQUs7UUFDOUIsSUFBSTJDLE9BQU8sQ0FBQzNDLEVBQUUsS0FBSyxLQUFJO1lBQ3JCLElBQUkyQyxPQUFPLENBQUMzQyxJQUFFLEVBQUUsS0FBSyxLQUFLO2dCQUN0QixNQUFNK0MsYUFBYUMsaUJBQWlCTCxTQUFTLEtBQUszQyxHQUFHLENBQUMsRUFBRUksUUFBUSxjQUFjLENBQUM7Z0JBQy9FLElBQUlnRyxlQUFlekQsUUFBUU0sU0FBUyxDQUFDakQsSUFBRSxHQUFFK0MsWUFBWW5DLElBQUk7Z0JBQ3pELElBQUd3RixpQkFBaUJoRyxTQUFRO29CQUMxQitGO29CQUNBLElBQUlBLGlCQUFpQixHQUFHO3dCQUN0QixPQUFPOzRCQUNMdEIsWUFBWWxDLFFBQVFNLFNBQVMsQ0FBQ2lELFlBQVlsRzs0QkFDMUNBLEdBQUkrQzt3QkFDTjtvQkFDRjtnQkFDRjtnQkFDQS9DLElBQUUrQztZQUNKLE9BQU8sSUFBR0osT0FBTyxDQUFDM0MsSUFBRSxFQUFFLEtBQUssS0FBSztnQkFDOUIsTUFBTStDLGFBQWFDLGlCQUFpQkwsU0FBUyxNQUFNM0MsSUFBRSxHQUFHO2dCQUN4REEsSUFBRStDO1lBQ0osT0FBTyxJQUFHSixRQUFRUyxNQUFNLENBQUNwRCxJQUFJLEdBQUcsT0FBTyxPQUFPO2dCQUM1QyxNQUFNK0MsYUFBYUMsaUJBQWlCTCxTQUFTLE9BQU8zQyxJQUFFLEdBQUc7Z0JBQ3pEQSxJQUFFK0M7WUFDSixPQUFPLElBQUdKLFFBQVFTLE1BQU0sQ0FBQ3BELElBQUksR0FBRyxPQUFPLE1BQU07Z0JBQzNDLE1BQU0rQyxhQUFhQyxpQkFBaUJMLFNBQVMsT0FBTzNDLEdBQUcsNkJBQTZCO2dCQUNwRkEsSUFBRStDO1lBQ0osT0FBTztnQkFDTCxNQUFNYSxVQUFVQyxXQUFXbEIsU0FBUzNDLEdBQUc7Z0JBRXZDLElBQUk0RCxTQUFTO29CQUNYLE1BQU15QyxjQUFjekMsV0FBV0EsUUFBUXhELE9BQU87b0JBQzlDLElBQUlpRyxnQkFBZ0JqRyxXQUFXd0QsUUFBUU8sTUFBTSxDQUFDUCxRQUFRTyxNQUFNLENBQUNsRSxNQUFNLEdBQUMsRUFBRSxLQUFLLEtBQUs7d0JBQzlFa0c7b0JBQ0Y7b0JBQ0FuRyxJQUFFNEQsUUFBUWIsVUFBVTtnQkFDdEI7WUFDRjtRQUNGO0lBQ0osRUFBQyxjQUFjO0FBQ2pCO0FBRUEsU0FBU2hDLFdBQVdoQyxHQUFHLEVBQUV1SCxXQUFXLEVBQUU3SCxPQUFPO0lBQzNDLElBQUk2SCxlQUFlLE9BQU92SCxRQUFRLFVBQVU7UUFDMUMsc0JBQXNCO1FBQ3RCLE1BQU04QixTQUFTOUIsSUFBSTZCLElBQUk7UUFDdkIsSUFBR0MsV0FBVyxRQUFTLE9BQU87YUFDekIsSUFBR0EsV0FBVyxTQUFVLE9BQU87YUFDL0IsT0FBTzFDLFNBQVNZLEtBQUtOO0lBQzVCLE9BQU87UUFDTCxJQUFJVixLQUFLd0ksT0FBTyxDQUFDeEgsTUFBTTtZQUNyQixPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBR0F5SCxPQUFPQyxPQUFPLEdBQUdsSSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC14bWwtcGFyc2VyQDQuMi41L25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9PcmRlcmVkT2JqUGFyc2VyLmpzP2E2NWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8vQHRzLWNoZWNrXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB4bWxOb2RlID0gcmVxdWlyZSgnLi94bWxOb2RlJyk7XG5jb25zdCByZWFkRG9jVHlwZSA9IHJlcXVpcmUoXCIuL0RvY1R5cGVSZWFkZXJcIik7XG5jb25zdCB0b051bWJlciA9IHJlcXVpcmUoXCJzdHJudW1cIik7XG5cbmNvbnN0IHJlZ3ggPVxuICAnPCgoIVxcXFxbQ0RBVEFcXFxcWyhbXFxcXHNcXFxcU10qPykoXV0+KSl8KChOQU1FOik/KE5BTUUpKShbXj5dKik+fCgoXFxcXC8pKE5BTUUpXFxcXHMqPikpKFtePF0qKSdcbiAgLnJlcGxhY2UoL05BTUUvZywgdXRpbC5uYW1lUmVnZXhwKTtcblxuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvP1tcXFxcdzpcXFxcLVxcLl9dKykoW14+XSopPihcXFxccypcIitjZGF0YVJlZ3grXCIpKihbXjxdKyk/XCIsXCJnXCIpO1xuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvPykoKFxcXFx3KjopPyhbXFxcXHc6XFxcXC1cXC5fXSspKShbXj5dKik+KFtePF0qKShcIitjZGF0YVJlZ3grXCIoW148XSopKSooW148XSspP1wiLFwiZ1wiKTtcblxuY2xhc3MgT3JkZXJlZE9ialBhcnNlcntcbiAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLnRhZ3NOb2RlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmRvY1R5cGVFbnRpdGllcyA9IHt9O1xuICAgIHRoaXMubGFzdEVudGl0aWVzID0ge1xuICAgICAgXCJhcG9zXCIgOiB7IHJlZ2V4OiAvJihhcG9zfCMzOXwjeDI3KTsvZywgdmFsIDogXCInXCJ9LFxuICAgICAgXCJndFwiIDogeyByZWdleDogLyYoZ3R8IzYyfCN4M0UpOy9nLCB2YWwgOiBcIj5cIn0sXG4gICAgICBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjB8I3gzQyk7L2csIHZhbCA6IFwiPFwifSxcbiAgICAgIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzR8I3gyMik7L2csIHZhbCA6IFwiXFxcIlwifSxcbiAgICB9O1xuICAgIHRoaXMuYW1wRW50aXR5ID0geyByZWdleDogLyYoYW1wfCMzOHwjeDI2KTsvZywgdmFsIDogXCImXCJ9O1xuICAgIHRoaXMuaHRtbEVudGl0aWVzID0ge1xuICAgICAgXCJzcGFjZVwiOiB7IHJlZ2V4OiAvJihuYnNwfCMxNjApOy9nLCB2YWw6IFwiIFwiIH0sXG4gICAgICAvLyBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjApOy9nLCB2YWw6IFwiPFwiIH0sXG4gICAgICAvLyBcImd0XCIgOiB7IHJlZ2V4OiAvJihndHwjNjIpOy9nLCB2YWw6IFwiPlwiIH0sXG4gICAgICAvLyBcImFtcFwiIDogeyByZWdleDogLyYoYW1wfCMzOCk7L2csIHZhbDogXCImXCIgfSxcbiAgICAgIC8vIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzQpOy9nLCB2YWw6IFwiXFxcIlwiIH0sXG4gICAgICAvLyBcImFwb3NcIiA6IHsgcmVnZXg6IC8mKGFwb3N8IzM5KTsvZywgdmFsOiBcIidcIiB9LFxuICAgICAgXCJjZW50XCIgOiB7IHJlZ2V4OiAvJihjZW50fCMxNjIpOy9nLCB2YWw6IFwiwqJcIiB9LFxuICAgICAgXCJwb3VuZFwiIDogeyByZWdleDogLyYocG91bmR8IzE2Myk7L2csIHZhbDogXCLCo1wiIH0sXG4gICAgICBcInllblwiIDogeyByZWdleDogLyYoeWVufCMxNjUpOy9nLCB2YWw6IFwiwqVcIiB9LFxuICAgICAgXCJldXJvXCIgOiB7IHJlZ2V4OiAvJihldXJvfCM4MzY0KTsvZywgdmFsOiBcIuKCrFwiIH0sXG4gICAgICBcImNvcHlyaWdodFwiIDogeyByZWdleDogLyYoY29weXwjMTY5KTsvZywgdmFsOiBcIsKpXCIgfSxcbiAgICAgIFwicmVnXCIgOiB7IHJlZ2V4OiAvJihyZWd8IzE3NCk7L2csIHZhbDogXCLCrlwiIH0sXG4gICAgICBcImluclwiIDogeyByZWdleDogLyYoaW5yfCM4Mzc3KTsvZywgdmFsOiBcIuKCuVwiIH0sXG4gICAgfTtcbiAgICB0aGlzLmFkZEV4dGVybmFsRW50aXRpZXMgPSBhZGRFeHRlcm5hbEVudGl0aWVzO1xuICAgIHRoaXMucGFyc2VYbWwgPSBwYXJzZVhtbDtcbiAgICB0aGlzLnBhcnNlVGV4dERhdGEgPSBwYXJzZVRleHREYXRhO1xuICAgIHRoaXMucmVzb2x2ZU5hbWVTcGFjZSA9IHJlc29sdmVOYW1lU3BhY2U7XG4gICAgdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAgPSBidWlsZEF0dHJpYnV0ZXNNYXA7XG4gICAgdGhpcy5pc0l0U3RvcE5vZGUgPSBpc0l0U3RvcE5vZGU7XG4gICAgdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSA9IHJlcGxhY2VFbnRpdGllc1ZhbHVlO1xuICAgIHRoaXMucmVhZFN0b3BOb2RlRGF0YSA9IHJlYWRTdG9wTm9kZURhdGE7XG4gICAgdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnID0gc2F2ZVRleHRUb1BhcmVudFRhZztcbiAgICB0aGlzLmFkZENoaWxkID0gYWRkQ2hpbGQ7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBhZGRFeHRlcm5hbEVudGl0aWVzKGV4dGVybmFsRW50aXRpZXMpe1xuICBjb25zdCBlbnRLZXlzID0gT2JqZWN0LmtleXMoZXh0ZXJuYWxFbnRpdGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW50S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVudCA9IGVudEtleXNbaV07XG4gICAgdGhpcy5sYXN0RW50aXRpZXNbZW50XSA9IHtcbiAgICAgICByZWdleDogbmV3IFJlZ0V4cChcIiZcIitlbnQrXCI7XCIsXCJnXCIpLFxuICAgICAgIHZhbCA6IGV4dGVybmFsRW50aXRpZXNbZW50XVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30galBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFRyaW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQXR0cmlidXRlc1xuICogQHBhcmFtIHtib29sZWFufSBpc0xlYWZOb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY2FwZUVudGl0aWVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEodmFsLCB0YWdOYW1lLCBqUGF0aCwgZG9udFRyaW0sIGhhc0F0dHJpYnV0ZXMsIGlzTGVhZk5vZGUsIGVzY2FwZUVudGl0aWVzKSB7XG4gIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudHJpbVZhbHVlcyAmJiAhZG9udFRyaW0pIHtcbiAgICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgfVxuICAgIGlmKHZhbC5sZW5ndGggPiAwKXtcbiAgICAgIGlmKCFlc2NhcGVFbnRpdGllcykgdmFsID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSh2YWwpO1xuICAgICAgXG4gICAgICBjb25zdCBuZXd2YWwgPSB0aGlzLm9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3IodGFnTmFtZSwgdmFsLCBqUGF0aCwgaGFzQXR0cmlidXRlcywgaXNMZWFmTm9kZSk7XG4gICAgICBpZihuZXd2YWwgPT09IG51bGwgfHwgbmV3dmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgICAvL2Rvbid0IHBhcnNlXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9ZWxzZSBpZih0eXBlb2YgbmV3dmFsICE9PSB0eXBlb2YgdmFsIHx8IG5ld3ZhbCAhPT0gdmFsKXtcbiAgICAgICAgLy9vdmVyd3JpdGVcbiAgICAgICAgcmV0dXJuIG5ld3ZhbDtcbiAgICAgIH1lbHNlIGlmKHRoaXMub3B0aW9ucy50cmltVmFsdWVzKXtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodmFsLCB0aGlzLm9wdGlvbnMucGFyc2VUYWdWYWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9ucyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc3QgdHJpbW1lZFZhbCA9IHZhbC50cmltKCk7XG4gICAgICAgIGlmKHRyaW1tZWRWYWwgPT09IHZhbCl7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodmFsLCB0aGlzLm9wdGlvbnMucGFyc2VUYWdWYWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9ucyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5hbWVTcGFjZSh0YWduYW1lKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlTlNQcmVmaXgpIHtcbiAgICBjb25zdCB0YWdzID0gdGFnbmFtZS5zcGxpdCgnOicpO1xuICAgIGNvbnN0IHByZWZpeCA9IHRhZ25hbWUuY2hhckF0KDApID09PSAnLycgPyAnLycgOiAnJztcbiAgICBpZiAodGFnc1swXSA9PT0gJ3htbG5zJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodGFncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRhZ25hbWUgPSBwcmVmaXggKyB0YWdzWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFnbmFtZTtcbn1cblxuLy9UT0RPOiBjaGFuZ2UgcmVnZXggdG8gY2FwdHVyZSBOU1xuLy9jb25zdCBhdHRyc1JlZ3ggPSBuZXcgUmVnRXhwKFwiKFtcXFxcd1xcXFwtXFxcXC5cXFxcOl0rKVxcXFxzKj1cXFxccyooWydcXFwiXSkoKC58XFxuKSo/KVxcXFwyXCIsXCJnbVwiKTtcbmNvbnN0IGF0dHJzUmVneCA9IG5ldyBSZWdFeHAoJyhbXlxcXFxzPV0rKVxcXFxzKig9XFxcXHMqKFtcXCdcIl0pKFtcXFxcc1xcXFxTXSo/KVxcXFwzKT8nLCAnZ20nKTtcblxuZnVuY3Rpb24gYnVpbGRBdHRyaWJ1dGVzTWFwKGF0dHJTdHIsIGpQYXRoLCB0YWdOYW1lKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZUF0dHJpYnV0ZXMgJiYgdHlwZW9mIGF0dHJTdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYXR0clN0ciA9IGF0dHJTdHIucmVwbGFjZSgvXFxyP1xcbi9nLCAnICcpO1xuICAgIC8vYXR0clN0ciA9IGF0dHJTdHIgfHwgYXR0clN0ci50cmltKCk7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gdXRpbC5nZXRBbGxNYXRjaGVzKGF0dHJTdHIsIGF0dHJzUmVneCk7XG4gICAgY29uc3QgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IC8vZG9uJ3QgbWFrZSBpdCBpbmxpbmVcbiAgICBjb25zdCBhdHRycyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5yZXNvbHZlTmFtZVNwYWNlKG1hdGNoZXNbaV1bMV0pO1xuICAgICAgbGV0IG9sZFZhbCA9IG1hdGNoZXNbaV1bNF07XG4gICAgICBsZXQgYU5hbWUgPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeCArIGF0dHJOYW1lO1xuICAgICAgaWYgKGF0dHJOYW1lLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zZm9ybUF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICBhTmFtZSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lKGFOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZihhTmFtZSA9PT0gXCJfX3Byb3RvX19cIikgYU5hbWUgID0gXCIjX19wcm90b19fXCI7XG4gICAgICAgIGlmIChvbGRWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJpbVZhbHVlcykge1xuICAgICAgICAgICAgb2xkVmFsID0gb2xkVmFsLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2xkVmFsID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZShvbGRWYWwpO1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcihhdHRyTmFtZSwgb2xkVmFsLCBqUGF0aCk7XG4gICAgICAgICAgaWYobmV3VmFsID09PSBudWxsIHx8IG5ld1ZhbCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIC8vZG9uJ3QgcGFyc2VcbiAgICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IG9sZFZhbDtcbiAgICAgICAgICB9ZWxzZSBpZih0eXBlb2YgbmV3VmFsICE9PSB0eXBlb2Ygb2xkVmFsIHx8IG5ld1ZhbCAhPT0gb2xkVmFsKXtcbiAgICAgICAgICAgIC8vb3ZlcndyaXRlXG4gICAgICAgICAgICBhdHRyc1thTmFtZV0gPSBuZXdWYWw7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL3BhcnNlXG4gICAgICAgICAgICBhdHRyc1thTmFtZV0gPSBwYXJzZVZhbHVlKFxuICAgICAgICAgICAgICBvbGRWYWwsXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXJzZUF0dHJpYnV0ZVZhbHVlLFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubnVtYmVyUGFyc2VPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dCb29sZWFuQXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZSkge1xuICAgICAgY29uc3QgYXR0ckNvbGxlY3Rpb24gPSB7fTtcbiAgICAgIGF0dHJDb2xsZWN0aW9uW3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVzR3JvdXBOYW1lXSA9IGF0dHJzO1xuICAgICAgcmV0dXJuIGF0dHJDb2xsZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnNcbiAgfVxufVxuXG5jb25zdCBwYXJzZVhtbCA9IGZ1bmN0aW9uKHhtbERhdGEpIHtcbiAgeG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTsgLy9UT0RPOiByZW1vdmUgdGhpcyBsaW5lXG4gIGNvbnN0IHhtbE9iaiA9IG5ldyB4bWxOb2RlKCcheG1sJyk7XG4gIGxldCBjdXJyZW50Tm9kZSA9IHhtbE9iajtcbiAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgbGV0IGpQYXRoID0gXCJcIjtcbiAgZm9yKGxldCBpPTA7IGk8IHhtbERhdGEubGVuZ3RoOyBpKyspey8vZm9yIGVhY2ggY2hhciBpbiBYTUwgZGF0YVxuICAgIGNvbnN0IGNoID0geG1sRGF0YVtpXTtcbiAgICBpZihjaCA9PT0gJzwnKXtcbiAgICAgIC8vIGNvbnN0IG5leHRJbmRleCA9IGkrMTtcbiAgICAgIC8vIGNvbnN0IF8ybmRDaGFyID0geG1sRGF0YVtuZXh0SW5kZXhdO1xuICAgICAgaWYoIHhtbERhdGFbaSsxXSA9PT0gJy8nKSB7Ly9DbG9zaW5nIFRhZ1xuICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIj5cIiwgaSwgXCJDbG9zaW5nIFRhZyBpcyBub3QgY2xvc2VkLlwiKVxuICAgICAgICBsZXQgdGFnTmFtZSA9IHhtbERhdGEuc3Vic3RyaW5nKGkrMixjbG9zZUluZGV4KS50cmltKCk7XG5cbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KXtcbiAgICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gdGFnTmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgICBpZihjb2xvbkluZGV4ICE9PSAtMSl7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoY29sb25JbmRleCsxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSkge1xuICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN1cnJlbnROb2RlKXtcbiAgICAgICAgICB0ZXh0RGF0YSA9IHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgaWYgbGFzdCB0YWcgb2YgbmVzdGVkIHRhZyB3YXMgdW5wYWlyZWQgdGFnXG4gICAgICAgIGNvbnN0IGxhc3RUYWdOYW1lID0galBhdGguc3Vic3RyaW5nKGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSsxKTtcbiAgICAgICAgaWYodGFnTmFtZSAmJiB0aGlzLm9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2YodGFnTmFtZSkgIT09IC0xICl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnBhaXJlZCB0YWcgY2FuIG5vdCBiZSB1c2VkIGFzIGNsb3NpbmcgdGFnOiA8LyR7dGFnTmFtZX0+YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3BJbmRleCA9IDBcbiAgICAgICAgaWYobGFzdFRhZ05hbWUgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKGxhc3RUYWdOYW1lKSAhPT0gLTEgKXtcbiAgICAgICAgICBwcm9wSW5kZXggPSBqUGF0aC5sYXN0SW5kZXhPZignLicsIGpQYXRoLmxhc3RJbmRleE9mKCcuJyktMSlcbiAgICAgICAgICB0aGlzLnRhZ3NOb2RlU3RhY2sucG9wKCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHByb3BJbmRleCA9IGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cmluZygwLCBwcm9wSW5kZXgpO1xuXG4gICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy50YWdzTm9kZVN0YWNrLnBvcCgpOy8vYXZvaWQgcmVjdXJzaW9uLCBzZXQgdGhlIHBhcmVudCB0YWcgc2NvcGVcbiAgICAgICAgdGV4dERhdGEgPSBcIlwiO1xuICAgICAgICBpID0gY2xvc2VJbmRleDtcbiAgICAgIH0gZWxzZSBpZiggeG1sRGF0YVtpKzFdID09PSAnPycpIHtcblxuICAgICAgICBsZXQgdGFnRGF0YSA9IHJlYWRUYWdFeHAoeG1sRGF0YSxpLCBmYWxzZSwgXCI/PlwiKTtcbiAgICAgICAgaWYoIXRhZ0RhdGEpIHRocm93IG5ldyBFcnJvcihcIlBpIFRhZyBpcyBub3QgY2xvc2VkLlwiKTtcblxuICAgICAgICB0ZXh0RGF0YSA9IHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoKTtcbiAgICAgICAgaWYoICh0aGlzLm9wdGlvbnMuaWdub3JlRGVjbGFyYXRpb24gJiYgdGFnRGF0YS50YWdOYW1lID09PSBcIj94bWxcIikgfHwgdGhpcy5vcHRpb25zLmlnbm9yZVBpVGFncyl7XG5cbiAgICAgICAgfWVsc2V7XG4gIFxuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5ldyB4bWxOb2RlKHRhZ0RhdGEudGFnTmFtZSk7XG4gICAgICAgICAgY2hpbGROb2RlLmFkZCh0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lLCBcIlwiKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZih0YWdEYXRhLnRhZ05hbWUgIT09IHRhZ0RhdGEudGFnRXhwICYmIHRhZ0RhdGEuYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgY2hpbGROb2RlW1wiOkBcIl0gPSB0aGlzLmJ1aWxkQXR0cmlidXRlc01hcCh0YWdEYXRhLnRhZ0V4cCwgalBhdGgsIHRhZ0RhdGEudGFnTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgpXG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaSA9IHRhZ0RhdGEuY2xvc2VJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDMpID09PSAnIS0tJykge1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCItLT5cIiwgaSs0LCBcIkNvbW1lbnQgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSl7XG4gICAgICAgICAgY29uc3QgY29tbWVudCA9IHhtbERhdGEuc3Vic3RyaW5nKGkgKyA0LCBlbmRJbmRleCAtIDIpO1xuXG4gICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgICBjdXJyZW50Tm9kZS5hZGQodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSwgWyB7IFt0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lXSA6IGNvbW1lbnQgfSBdKTtcbiAgICAgICAgfVxuICAgICAgICBpID0gZW5kSW5kZXg7XG4gICAgICB9IGVsc2UgaWYoIHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFEJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkRG9jVHlwZSh4bWxEYXRhLCBpKTtcbiAgICAgICAgdGhpcy5kb2NUeXBlRW50aXRpZXMgPSByZXN1bHQuZW50aXRpZXM7XG4gICAgICAgIGkgPSByZXN1bHQuaTtcbiAgICAgIH1lbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFbJykge1xuICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIl1dPlwiLCBpLCBcIkNEQVRBIGlzIG5vdCBjbG9zZWQuXCIpIC0gMjtcbiAgICAgICAgY29uc3QgdGFnRXhwID0geG1sRGF0YS5zdWJzdHJpbmcoaSArIDksY2xvc2VJbmRleCk7XG5cbiAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgLy9jZGF0YSBzaG91bGQgYmUgc2V0IGV2ZW4gaWYgaXQgaXMgMCBsZW5ndGggc3RyaW5nXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lKXtcbiAgICAgICAgICAvLyBsZXQgdmFsID0gdGhpcy5wYXJzZVRleHREYXRhKHRhZ0V4cCwgdGhpcy5vcHRpb25zLmNkYXRhUHJvcE5hbWUsIGpQYXRoICsgXCIuXCIgKyB0aGlzLm9wdGlvbnMuY2RhdGFQcm9wTmFtZSwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIC8vIGlmKCF2YWwpIHZhbCA9IFwiXCI7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lLCBbIHsgW3RoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWVdIDogdGFnRXhwIH0gXSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnRXhwLCBjdXJyZW50Tm9kZS50YWduYW1lLCBqUGF0aCwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGlmKHZhbCA9PSB1bmRlZmluZWQpIHZhbCA9IFwiXCI7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGkgPSBjbG9zZUluZGV4ICsgMjtcbiAgICAgIH1lbHNlIHsvL09wZW5pbmcgdGFnXG4gICAgICAgIGxldCByZXN1bHQgPSByZWFkVGFnRXhwKHhtbERhdGEsaSwgdGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KTtcbiAgICAgICAgbGV0IHRhZ05hbWU9IHJlc3VsdC50YWdOYW1lO1xuICAgICAgICBsZXQgdGFnRXhwID0gcmVzdWx0LnRhZ0V4cDtcbiAgICAgICAgbGV0IGF0dHJFeHBQcmVzZW50ID0gcmVzdWx0LmF0dHJFeHBQcmVzZW50O1xuICAgICAgICBsZXQgY2xvc2VJbmRleCA9IHJlc3VsdC5jbG9zZUluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSkge1xuICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy9zYXZlIHRleHQgYXMgY2hpbGQgbm9kZVxuICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgdGV4dERhdGEpIHtcbiAgICAgICAgICBpZihjdXJyZW50Tm9kZS50YWduYW1lICE9PSAnIXhtbCcpe1xuICAgICAgICAgICAgLy93aGVuIG5lc3RlZCB0YWcgaXMgZm91bmRcbiAgICAgICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGlmIGxhc3QgdGFnIHdhcyB1bnBhaXJlZCB0YWdcbiAgICAgICAgY29uc3QgbGFzdFRhZyA9IGN1cnJlbnROb2RlO1xuICAgICAgICBpZihsYXN0VGFnICYmIHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihsYXN0VGFnLnRhZ25hbWUpICE9PSAtMSApe1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy50YWdzTm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyaW5nKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnTmFtZSAhPT0geG1sT2JqLnRhZ25hbWUpe1xuICAgICAgICAgIGpQYXRoICs9IGpQYXRoID8gXCIuXCIgKyB0YWdOYW1lIDogdGFnTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0l0U3RvcE5vZGUodGhpcy5vcHRpb25zLnN0b3BOb2RlcywgalBhdGgsIHRhZ05hbWUpKSB7IC8vVE9ETzogbmFtZXNwYWNlXG4gICAgICAgICAgbGV0IHRhZ0NvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIC8vc2VsZi1jbG9zaW5nIHRhZ1xuICAgICAgICAgIGlmKHRhZ0V4cC5sZW5ndGggPiAwICYmIHRhZ0V4cC5sYXN0SW5kZXhPZihcIi9cIikgPT09IHRhZ0V4cC5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIGkgPSByZXN1bHQuY2xvc2VJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy91bnBhaXJlZCB0YWdcbiAgICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpe1xuICAgICAgICAgICAgaSA9IHJlc3VsdC5jbG9zZUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL25vcm1hbCB0YWdcbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgLy9yZWFkIHVudGlsIGNsb3NpbmcgdGFnIGlzIGZvdW5kXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlYWRTdG9wTm9kZURhdGEoeG1sRGF0YSwgdGFnTmFtZSwgY2xvc2VJbmRleCArIDEpO1xuICAgICAgICAgICAgaWYoIXJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVuZCBvZiAke3RhZ05hbWV9YCk7XG4gICAgICAgICAgICBpID0gcmVzdWx0Lmk7XG4gICAgICAgICAgICB0YWdDb250ZW50ID0gcmVzdWx0LnRhZ0NvbnRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUodGFnTmFtZSk7XG4gICAgICAgICAgaWYodGFnTmFtZSAhPT0gdGFnRXhwICYmIGF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRXhwLCBqUGF0aCwgdGFnTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRhZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRhZ0NvbnRlbnQgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnQ29udGVudCwgdGFnTmFtZSwgalBhdGgsIHRydWUsIGF0dHJFeHBQcmVzZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHIoMCwgalBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgICBjaGlsZE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHRhZ0NvbnRlbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgpXG4gICAgICAgIH1lbHNle1xuICAvL3NlbGZDbG9zaW5nIHRhZ1xuICAgICAgICAgIGlmKHRhZ0V4cC5sZW5ndGggPiAwICYmIHRhZ0V4cC5sYXN0SW5kZXhPZihcIi9cIikgPT09IHRhZ0V4cC5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIGlmKHRhZ05hbWVbdGFnTmFtZS5sZW5ndGggLSAxXSA9PT0gXCIvXCIpeyAvL3JlbW92ZSB0cmFpbGluZyAnLydcbiAgICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyKDAsIHRhZ05hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIHRhZ0V4cCA9IHRhZ05hbWU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdGFnRXhwID0gdGFnRXhwLnN1YnN0cigwLCB0YWdFeHAubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKSB7XG4gICAgICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUodGFnTmFtZSk7XG4gICAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0V4cCwgalBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aClcbiAgICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgICAgfVxuICAgIC8vb3BlbmluZyB0YWdcbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUoIHRhZ05hbWUpO1xuICAgICAgICAgICAgdGhpcy50YWdzTm9kZVN0YWNrLnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0V4cCwgalBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aClcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0RGF0YSA9IFwiXCI7XG4gICAgICAgICAgaSA9IGNsb3NlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIHRleHREYXRhICs9IHhtbERhdGFbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiB4bWxPYmouY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkKGN1cnJlbnROb2RlLCBjaGlsZE5vZGUsIGpQYXRoKXtcbiAgY29uc3QgcmVzdWx0ID0gdGhpcy5vcHRpb25zLnVwZGF0ZVRhZyhjaGlsZE5vZGUudGFnbmFtZSwgalBhdGgsIGNoaWxkTm9kZVtcIjpAXCJdKVxuICBpZihyZXN1bHQgPT09IGZhbHNlKXtcbiAgfWVsc2UgaWYodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIil7XG4gICAgY2hpbGROb2RlLnRhZ25hbWUgPSByZXN1bHRcbiAgICBjdXJyZW50Tm9kZS5hZGRDaGlsZChjaGlsZE5vZGUpO1xuICB9ZWxzZXtcbiAgICBjdXJyZW50Tm9kZS5hZGRDaGlsZChjaGlsZE5vZGUpO1xuICB9XG59XG5cbmNvbnN0IHJlcGxhY2VFbnRpdGllc1ZhbHVlID0gZnVuY3Rpb24odmFsKXtcblxuICBpZih0aGlzLm9wdGlvbnMucHJvY2Vzc0VudGl0aWVzKXtcbiAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5kb2NUeXBlRW50aXRpZXMpe1xuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5kb2NUeXBlRW50aXRpZXNbZW50aXR5TmFtZV07XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ3gsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5sYXN0RW50aXRpZXMpe1xuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5sYXN0RW50aXRpZXNbZW50aXR5TmFtZV07XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ2V4LCBlbnRpdHkudmFsKTtcbiAgICB9XG4gICAgaWYodGhpcy5vcHRpb25zLmh0bWxFbnRpdGllcyl7XG4gICAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5odG1sRW50aXRpZXMpe1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmh0bWxFbnRpdGllc1tlbnRpdHlOYW1lXTtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoIGVudGl0eS5yZWdleCwgZW50aXR5LnZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbCA9IHZhbC5yZXBsYWNlKCB0aGlzLmFtcEVudGl0eS5yZWdleCwgdGhpcy5hbXBFbnRpdHkudmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoLCBpc0xlYWZOb2RlKSB7XG4gIGlmICh0ZXh0RGF0YSkgeyAvL3N0b3JlIHByZXZpb3VzbHkgY29sbGVjdGVkIGRhdGEgYXMgdGV4dE5vZGVcbiAgICBpZihpc0xlYWZOb2RlID09PSB1bmRlZmluZWQpIGlzTGVhZk5vZGUgPSBPYmplY3Qua2V5cyhjdXJyZW50Tm9kZS5jaGlsZCkubGVuZ3RoID09PSAwXG4gICAgXG4gICAgdGV4dERhdGEgPSB0aGlzLnBhcnNlVGV4dERhdGEodGV4dERhdGEsXG4gICAgICBjdXJyZW50Tm9kZS50YWduYW1lLFxuICAgICAgalBhdGgsXG4gICAgICBmYWxzZSxcbiAgICAgIGN1cnJlbnROb2RlW1wiOkBcIl0gPyBPYmplY3Qua2V5cyhjdXJyZW50Tm9kZVtcIjpAXCJdKS5sZW5ndGggIT09IDAgOiBmYWxzZSxcbiAgICAgIGlzTGVhZk5vZGUpO1xuXG4gICAgaWYgKHRleHREYXRhICE9PSB1bmRlZmluZWQgJiYgdGV4dERhdGEgIT09IFwiXCIpXG4gICAgICBjdXJyZW50Tm9kZS5hZGQodGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSwgdGV4dERhdGEpO1xuICAgIHRleHREYXRhID0gXCJcIjtcbiAgfVxuICByZXR1cm4gdGV4dERhdGE7XG59XG5cbi8vVE9ETzogdXNlIGpQYXRoIHRvIHNpbXBsaWZ5IHRoZSBsb2dpY1xuLyoqXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nW119IHN0b3BOb2RlcyBcbiAqIEBwYXJhbSB7c3RyaW5nfSBqUGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRUYWdOYW1lIFxuICovXG5mdW5jdGlvbiBpc0l0U3RvcE5vZGUoc3RvcE5vZGVzLCBqUGF0aCwgY3VycmVudFRhZ05hbWUpe1xuICBjb25zdCBhbGxOb2Rlc0V4cCA9IFwiKi5cIiArIGN1cnJlbnRUYWdOYW1lO1xuICBmb3IgKGNvbnN0IHN0b3BOb2RlUGF0aCBpbiBzdG9wTm9kZXMpIHtcbiAgICBjb25zdCBzdG9wTm9kZUV4cCA9IHN0b3BOb2Rlc1tzdG9wTm9kZVBhdGhdO1xuICAgIGlmKCBhbGxOb2Rlc0V4cCA9PT0gc3RvcE5vZGVFeHAgfHwgalBhdGggPT09IHN0b3BOb2RlRXhwICApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0YWcgRXhwcmVzc2lvbiBhbmQgd2hlcmUgaXQgaXMgZW5kaW5nIGhhbmRsaW5nIHNpbmdsZS1kb3VibGUgcXVvdGVzIHNpdHVhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHhtbERhdGEgXG4gKiBAcGFyYW0ge251bWJlcn0gaSBzdGFydGluZyBpbmRleFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIHRhZ0V4cFdpdGhDbG9zaW5nSW5kZXgoeG1sRGF0YSwgaSwgY2xvc2luZ0NoYXIgPSBcIj5cIil7XG4gIGxldCBhdHRyQm91bmRhcnk7XG4gIGxldCB0YWdFeHAgPSBcIlwiO1xuICBmb3IgKGxldCBpbmRleCA9IGk7IGluZGV4IDwgeG1sRGF0YS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgY2ggPSB4bWxEYXRhW2luZGV4XTtcbiAgICBpZiAoYXR0ckJvdW5kYXJ5KSB7XG4gICAgICAgIGlmIChjaCA9PT0gYXR0ckJvdW5kYXJ5KSBhdHRyQm91bmRhcnkgPSBcIlwiOy8vcmVzZXRcbiAgICB9IGVsc2UgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikge1xuICAgICAgICBhdHRyQm91bmRhcnkgPSBjaDtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBjbG9zaW5nQ2hhclswXSkge1xuICAgICAgaWYoY2xvc2luZ0NoYXJbMV0pe1xuICAgICAgICBpZih4bWxEYXRhW2luZGV4ICsgMV0gPT09IGNsb3NpbmdDaGFyWzFdKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGFnRXhwLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB0YWdFeHAsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAnXFx0Jykge1xuICAgICAgY2ggPSBcIiBcIlxuICAgIH1cbiAgICB0YWdFeHAgKz0gY2g7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBzdHIsIGksIGVyck1zZyl7XG4gIGNvbnN0IGNsb3NpbmdJbmRleCA9IHhtbERhdGEuaW5kZXhPZihzdHIsIGkpO1xuICBpZihjbG9zaW5nSW5kZXggPT09IC0xKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKVxuICB9ZWxzZXtcbiAgICByZXR1cm4gY2xvc2luZ0luZGV4ICsgc3RyLmxlbmd0aCAtIDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFRhZ0V4cCh4bWxEYXRhLGksIHJlbW92ZU5TUHJlZml4LCBjbG9zaW5nQ2hhciA9IFwiPlwiKXtcbiAgY29uc3QgcmVzdWx0ID0gdGFnRXhwV2l0aENsb3NpbmdJbmRleCh4bWxEYXRhLCBpKzEsIGNsb3NpbmdDaGFyKTtcbiAgaWYoIXJlc3VsdCkgcmV0dXJuO1xuICBsZXQgdGFnRXhwID0gcmVzdWx0LmRhdGE7XG4gIGNvbnN0IGNsb3NlSW5kZXggPSByZXN1bHQuaW5kZXg7XG4gIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gdGFnRXhwLnNlYXJjaCgvXFxzLyk7XG4gIGxldCB0YWdOYW1lID0gdGFnRXhwO1xuICBsZXQgYXR0ckV4cFByZXNlbnQgPSB0cnVlO1xuICBpZihzZXBhcmF0b3JJbmRleCAhPT0gLTEpey8vc2VwYXJhdGUgdGFnIG5hbWUgYW5kIGF0dHJpYnV0ZXMgZXhwcmVzc2lvblxuICAgIHRhZ05hbWUgPSB0YWdFeHAuc3Vic3RyKDAsIHNlcGFyYXRvckluZGV4KS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB0YWdFeHAgPSB0YWdFeHAuc3Vic3RyKHNlcGFyYXRvckluZGV4ICsgMSk7XG4gIH1cblxuICBpZihyZW1vdmVOU1ByZWZpeCl7XG4gICAgY29uc3QgY29sb25JbmRleCA9IHRhZ05hbWUuaW5kZXhPZihcIjpcIik7XG4gICAgaWYoY29sb25JbmRleCAhPT0gLTEpe1xuICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyKGNvbG9uSW5kZXgrMSk7XG4gICAgICBhdHRyRXhwUHJlc2VudCA9IHRhZ05hbWUgIT09IHJlc3VsdC5kYXRhLnN1YnN0cihjb2xvbkluZGV4ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIHRhZ0V4cDogdGFnRXhwLFxuICAgIGNsb3NlSW5kZXg6IGNsb3NlSW5kZXgsXG4gICAgYXR0ckV4cFByZXNlbnQ6IGF0dHJFeHBQcmVzZW50LFxuICB9XG59XG4vKipcbiAqIGZpbmQgcGFpcmVkIHRhZyBmb3IgYSBzdG9wIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxEYXRhIFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgXG4gKiBAcGFyYW0ge251bWJlcn0gaSBcbiAqL1xuZnVuY3Rpb24gcmVhZFN0b3BOb2RlRGF0YSh4bWxEYXRhLCB0YWdOYW1lLCBpKXtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGk7XG4gIC8vIFN0YXJ0aW5nIGF0IDEgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIGFuIG9wZW4gdGFnXG4gIGxldCBvcGVuVGFnQ291bnQgPSAxO1xuXG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmKCB4bWxEYXRhW2ldID09PSBcIjxcIil7IFxuICAgICAgaWYgKHhtbERhdGFbaSsxXSA9PT0gXCIvXCIpIHsvL2Nsb3NlIHRhZ1xuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiPlwiLCBpLCBgJHt0YWdOYW1lfSBpcyBub3QgY2xvc2VkYCk7XG4gICAgICAgICAgbGV0IGNsb3NlVGFnTmFtZSA9IHhtbERhdGEuc3Vic3RyaW5nKGkrMixjbG9zZUluZGV4KS50cmltKCk7XG4gICAgICAgICAgaWYoY2xvc2VUYWdOYW1lID09PSB0YWdOYW1lKXtcbiAgICAgICAgICAgIG9wZW5UYWdDb3VudC0tO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhZ0NvbnRlbnQ6IHhtbERhdGEuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIGkpLFxuICAgICAgICAgICAgICAgIGkgOiBjbG9zZUluZGV4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2UgaWYoeG1sRGF0YVtpKzFdID09PSAnPycpIHsgXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCI/PlwiLCBpKzEsIFwiU3RvcE5vZGUgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZih4bWxEYXRhLnN1YnN0cihpICsgMSwgMykgPT09ICchLS0nKSB7IFxuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiLS0+XCIsIGkrMywgXCJTdG9wTm9kZSBpcyBub3QgY2xvc2VkLlwiKVxuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFbJykgeyBcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIl1dPlwiLCBpLCBcIlN0b3BOb2RlIGlzIG5vdCBjbG9zZWQuXCIpIC0gMjtcbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGFnRGF0YSA9IHJlYWRUYWdFeHAoeG1sRGF0YSwgaSwgJz4nKVxuXG4gICAgICAgICAgaWYgKHRhZ0RhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5UYWdOYW1lID0gdGFnRGF0YSAmJiB0YWdEYXRhLnRhZ05hbWU7XG4gICAgICAgICAgICBpZiAob3BlblRhZ05hbWUgPT09IHRhZ05hbWUgJiYgdGFnRGF0YS50YWdFeHBbdGFnRGF0YS50YWdFeHAubGVuZ3RoLTFdICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICBvcGVuVGFnQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGk9dGFnRGF0YS5jbG9zZUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICB9Ly9lbmQgZm9yIGxvb3Bcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWwsIHNob3VsZFBhcnNlLCBvcHRpb25zKSB7XG4gIGlmIChzaG91bGRQYXJzZSAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIC8vY29uc29sZS5sb2cob3B0aW9ucylcbiAgICBjb25zdCBuZXd2YWwgPSB2YWwudHJpbSgpO1xuICAgIGlmKG5ld3ZhbCA9PT0gJ3RydWUnICkgcmV0dXJuIHRydWU7XG4gICAgZWxzZSBpZihuZXd2YWwgPT09ICdmYWxzZScgKSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSByZXR1cm4gdG9OdW1iZXIodmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodXRpbC5pc0V4aXN0KHZhbCkpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IE9yZGVyZWRPYmpQYXJzZXI7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJ4bWxOb2RlIiwicmVhZERvY1R5cGUiLCJ0b051bWJlciIsInJlZ3giLCJyZXBsYWNlIiwibmFtZVJlZ2V4cCIsIk9yZGVyZWRPYmpQYXJzZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJjdXJyZW50Tm9kZSIsInRhZ3NOb2RlU3RhY2siLCJkb2NUeXBlRW50aXRpZXMiLCJsYXN0RW50aXRpZXMiLCJyZWdleCIsInZhbCIsImFtcEVudGl0eSIsImh0bWxFbnRpdGllcyIsImFkZEV4dGVybmFsRW50aXRpZXMiLCJwYXJzZVhtbCIsInBhcnNlVGV4dERhdGEiLCJyZXNvbHZlTmFtZVNwYWNlIiwiYnVpbGRBdHRyaWJ1dGVzTWFwIiwiaXNJdFN0b3BOb2RlIiwicmVwbGFjZUVudGl0aWVzVmFsdWUiLCJyZWFkU3RvcE5vZGVEYXRhIiwic2F2ZVRleHRUb1BhcmVudFRhZyIsImFkZENoaWxkIiwiZXh0ZXJuYWxFbnRpdGllcyIsImVudEtleXMiLCJPYmplY3QiLCJrZXlzIiwiaSIsImxlbmd0aCIsImVudCIsIlJlZ0V4cCIsInRhZ05hbWUiLCJqUGF0aCIsImRvbnRUcmltIiwiaGFzQXR0cmlidXRlcyIsImlzTGVhZk5vZGUiLCJlc2NhcGVFbnRpdGllcyIsInVuZGVmaW5lZCIsInRyaW1WYWx1ZXMiLCJ0cmltIiwibmV3dmFsIiwidGFnVmFsdWVQcm9jZXNzb3IiLCJwYXJzZVZhbHVlIiwicGFyc2VUYWdWYWx1ZSIsIm51bWJlclBhcnNlT3B0aW9ucyIsInRyaW1tZWRWYWwiLCJ0YWduYW1lIiwicmVtb3ZlTlNQcmVmaXgiLCJ0YWdzIiwic3BsaXQiLCJwcmVmaXgiLCJjaGFyQXQiLCJhdHRyc1JlZ3giLCJhdHRyU3RyIiwiaWdub3JlQXR0cmlidXRlcyIsIm1hdGNoZXMiLCJnZXRBbGxNYXRjaGVzIiwibGVuIiwiYXR0cnMiLCJhdHRyTmFtZSIsIm9sZFZhbCIsImFOYW1lIiwiYXR0cmlidXRlTmFtZVByZWZpeCIsInRyYW5zZm9ybUF0dHJpYnV0ZU5hbWUiLCJuZXdWYWwiLCJhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvciIsInBhcnNlQXR0cmlidXRlVmFsdWUiLCJhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzIiwiYXR0cmlidXRlc0dyb3VwTmFtZSIsImF0dHJDb2xsZWN0aW9uIiwieG1sRGF0YSIsInhtbE9iaiIsInRleHREYXRhIiwiY2giLCJjbG9zZUluZGV4IiwiZmluZENsb3NpbmdJbmRleCIsInN1YnN0cmluZyIsImNvbG9uSW5kZXgiLCJpbmRleE9mIiwic3Vic3RyIiwidHJhbnNmb3JtVGFnTmFtZSIsImxhc3RUYWdOYW1lIiwibGFzdEluZGV4T2YiLCJ1bnBhaXJlZFRhZ3MiLCJFcnJvciIsInByb3BJbmRleCIsInBvcCIsInRhZ0RhdGEiLCJyZWFkVGFnRXhwIiwiaWdub3JlRGVjbGFyYXRpb24iLCJpZ25vcmVQaVRhZ3MiLCJjaGlsZE5vZGUiLCJhZGQiLCJ0ZXh0Tm9kZU5hbWUiLCJ0YWdFeHAiLCJhdHRyRXhwUHJlc2VudCIsImVuZEluZGV4IiwiY29tbWVudFByb3BOYW1lIiwiY29tbWVudCIsInJlc3VsdCIsImVudGl0aWVzIiwiY2RhdGFQcm9wTmFtZSIsImxhc3RUYWciLCJzdG9wTm9kZXMiLCJ0YWdDb250ZW50IiwicHVzaCIsImNoaWxkIiwidXBkYXRlVGFnIiwicHJvY2Vzc0VudGl0aWVzIiwiZW50aXR5TmFtZSIsImVudGl0eSIsImN1cnJlbnRUYWdOYW1lIiwiYWxsTm9kZXNFeHAiLCJzdG9wTm9kZVBhdGgiLCJzdG9wTm9kZUV4cCIsInRhZ0V4cFdpdGhDbG9zaW5nSW5kZXgiLCJjbG9zaW5nQ2hhciIsImF0dHJCb3VuZGFyeSIsImluZGV4IiwiZGF0YSIsInN0ciIsImVyck1zZyIsImNsb3NpbmdJbmRleCIsInNlcGFyYXRvckluZGV4Iiwic2VhcmNoIiwic3RhcnRJbmRleCIsIm9wZW5UYWdDb3VudCIsImNsb3NlVGFnTmFtZSIsIm9wZW5UYWdOYW1lIiwic2hvdWxkUGFyc2UiLCJpc0V4aXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { buildOptions } = __webpack_require__(/*! ./OptionsBuilder */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\");\nconst OrderedObjParser = __webpack_require__(/*! ./OrderedObjParser */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\");\nconst { prettify } = __webpack_require__(/*! ./node2json */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/node2json.js\");\nconst validator = __webpack_require__(/*! ../validator */ \"(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/validator.js\");\nclass XMLParser {\n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */ parse(xmlData, validationOption) {\n        if (typeof xmlData === \"string\") {} else if (xmlData.toString) {\n            xmlData = xmlData.toString();\n        } else {\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\");\n        }\n        if (validationOption) {\n            if (validationOption === true) validationOption = {}; //validate with default options\n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n                throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);\n            }\n        }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if (this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */ addEntity(key, value) {\n        if (value.indexOf(\"&\") !== -1) {\n            throw new Error(\"Entity value can't have '&'\");\n        } else if (key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1) {\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n        } else if (value === \"&\") {\n            throw new Error(\"An entity with value '&' is not permitted\");\n        } else {\n            this.externalEntities[key] = value;\n        }\n    }\n}\nmodule.exports = XMLParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvWE1MUGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUVBLFlBQVksRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQywySUFBa0I7QUFDbEQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQywrSUFBb0I7QUFDckQsTUFBTSxFQUFFRSxRQUFRLEVBQUMsR0FBR0YsbUJBQU9BLENBQUMsaUlBQWE7QUFDekMsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUM7QUFFMUIsTUFBTUk7SUFFRkMsWUFBWUMsT0FBTyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUNELE9BQU8sR0FBR1AsYUFBYU87SUFFaEM7SUFDQTs7OztLQUlDLEdBQ0RFLE1BQU1DLE9BQU8sRUFBQ0MsZ0JBQWdCLEVBQUM7UUFDM0IsSUFBRyxPQUFPRCxZQUFZLFVBQVMsQ0FDL0IsT0FBTSxJQUFJQSxRQUFRRSxRQUFRLEVBQUM7WUFDdkJGLFVBQVVBLFFBQVFFLFFBQVE7UUFDOUIsT0FBSztZQUNELE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUlGLGtCQUFpQjtZQUNqQixJQUFHQSxxQkFBcUIsTUFBTUEsbUJBQW1CLENBQUMsR0FBRywrQkFBK0I7WUFFcEYsTUFBTUcsU0FBU1YsVUFBVVcsUUFBUSxDQUFDTCxTQUFTQztZQUMzQyxJQUFJRyxXQUFXLE1BQU07Z0JBQ25CLE1BQU1ELE1BQU8sQ0FBQyxFQUFFQyxPQUFPRSxHQUFHLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUVILE9BQU9FLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDLENBQUMsRUFBRUosT0FBT0UsR0FBRyxDQUFDRyxHQUFHLENBQUMsQ0FBQztZQUN2RTtRQUNGO1FBQ0YsTUFBTUMsbUJBQW1CLElBQUlsQixpQkFBaUIsSUFBSSxDQUFDSyxPQUFPO1FBQzFEYSxpQkFBaUJDLG1CQUFtQixDQUFDLElBQUksQ0FBQ2IsZ0JBQWdCO1FBQzFELE1BQU1jLGdCQUFnQkYsaUJBQWlCRyxRQUFRLENBQUNiO1FBQ2hELElBQUcsSUFBSSxDQUFDSCxPQUFPLENBQUNpQixhQUFhLElBQUlGLGtCQUFrQkcsV0FBVyxPQUFPSDthQUNoRSxPQUFPbkIsU0FBU21CLGVBQWUsSUFBSSxDQUFDZixPQUFPO0lBQ3BEO0lBRUE7Ozs7S0FJQyxHQUNEbUIsVUFBVUMsR0FBRyxFQUFFQyxLQUFLLEVBQUM7UUFDakIsSUFBR0EsTUFBTUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFFO1lBQ3pCLE1BQU0sSUFBSWhCLE1BQU07UUFDcEIsT0FBTSxJQUFHYyxJQUFJRSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUtGLElBQUlFLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRTtZQUN4RCxNQUFNLElBQUloQixNQUFNO1FBQ3BCLE9BQU0sSUFBR2UsVUFBVSxLQUFJO1lBQ25CLE1BQU0sSUFBSWYsTUFBTTtRQUNwQixPQUFLO1lBQ0QsSUFBSSxDQUFDTCxnQkFBZ0IsQ0FBQ21CLElBQUksR0FBR0M7UUFDakM7SUFDSjtBQUNKO0FBRUFFLE9BQU9DLE9BQU8sR0FBRzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXhtbC1wYXJzZXJANC4yLjUvbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL1hNTFBhcnNlci5qcz80NDFlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYnVpbGRPcHRpb25zfSA9IHJlcXVpcmUoXCIuL09wdGlvbnNCdWlsZGVyXCIpO1xuY29uc3QgT3JkZXJlZE9ialBhcnNlciA9IHJlcXVpcmUoXCIuL09yZGVyZWRPYmpQYXJzZXJcIik7XG5jb25zdCB7IHByZXR0aWZ5fSA9IHJlcXVpcmUoXCIuL25vZGUyanNvblwiKTtcbmNvbnN0IHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcicpO1xuXG5jbGFzcyBYTUxQYXJzZXJ7XG4gICAgXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxFbnRpdGllcyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBidWlsZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBYTUwgZGF0cyB0byBKUyBvYmplY3QgXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSB4bWxEYXRhIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IHZhbGlkYXRpb25PcHRpb24gXG4gICAgICovXG4gICAgcGFyc2UoeG1sRGF0YSx2YWxpZGF0aW9uT3B0aW9uKXtcbiAgICAgICAgaWYodHlwZW9mIHhtbERhdGEgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICB9ZWxzZSBpZiggeG1sRGF0YS50b1N0cmluZyl7XG4gICAgICAgICAgICB4bWxEYXRhID0geG1sRGF0YS50b1N0cmluZygpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlhNTCBkYXRhIGlzIGFjY2VwdGVkIGluIFN0cmluZyBvciBCeXRlc1tdIGZvcm0uXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYoIHZhbGlkYXRpb25PcHRpb24pe1xuICAgICAgICAgICAgaWYodmFsaWRhdGlvbk9wdGlvbiA9PT0gdHJ1ZSkgdmFsaWRhdGlvbk9wdGlvbiA9IHt9OyAvL3ZhbGlkYXRlIHdpdGggZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZSh4bWxEYXRhLCB2YWxpZGF0aW9uT3B0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIGAke3Jlc3VsdC5lcnIubXNnfToke3Jlc3VsdC5lcnIubGluZX06JHtyZXN1bHQuZXJyLmNvbH1gIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yZGVyZWRPYmpQYXJzZXIgPSBuZXcgT3JkZXJlZE9ialBhcnNlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICBvcmRlcmVkT2JqUGFyc2VyLmFkZEV4dGVybmFsRW50aXRpZXModGhpcy5leHRlcm5hbEVudGl0aWVzKTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZFJlc3VsdCA9IG9yZGVyZWRPYmpQYXJzZXIucGFyc2VYbWwoeG1sRGF0YSk7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZU9yZGVyIHx8IG9yZGVyZWRSZXN1bHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9yZGVyZWRSZXN1bHQ7XG4gICAgICAgIGVsc2UgcmV0dXJuIHByZXR0aWZ5KG9yZGVyZWRSZXN1bHQsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIEVudGl0eSB3aGljaCBpcyBub3QgYnkgZGVmYXVsdCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG4gICAgICovXG4gICAgYWRkRW50aXR5KGtleSwgdmFsdWUpe1xuICAgICAgICBpZih2YWx1ZS5pbmRleE9mKFwiJlwiKSAhPT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50aXR5IHZhbHVlIGNhbid0IGhhdmUgJyYnXCIpXG4gICAgICAgIH1lbHNlIGlmKGtleS5pbmRleE9mKFwiJlwiKSAhPT0gLTEgfHwga2V5LmluZGV4T2YoXCI7XCIpICE9PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBlbnRpdHkgbXVzdCBiZSBzZXQgd2l0aG91dCAnJicgYW5kICc7Jy4gRWcuIHVzZSAnI3hEJyBmb3IgJyYjeEQ7J1wiKVxuICAgICAgICB9ZWxzZSBpZih2YWx1ZSA9PT0gXCImXCIpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZW50aXR5IHdpdGggdmFsdWUgJyYnIGlzIG5vdCBwZXJtaXR0ZWRcIik7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5leHRlcm5hbEVudGl0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBYTUxQYXJzZXI7Il0sIm5hbWVzIjpbImJ1aWxkT3B0aW9ucyIsInJlcXVpcmUiLCJPcmRlcmVkT2JqUGFyc2VyIiwicHJldHRpZnkiLCJ2YWxpZGF0b3IiLCJYTUxQYXJzZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJleHRlcm5hbEVudGl0aWVzIiwicGFyc2UiLCJ4bWxEYXRhIiwidmFsaWRhdGlvbk9wdGlvbiIsInRvU3RyaW5nIiwiRXJyb3IiLCJyZXN1bHQiLCJ2YWxpZGF0ZSIsImVyciIsIm1zZyIsImxpbmUiLCJjb2wiLCJvcmRlcmVkT2JqUGFyc2VyIiwiYWRkRXh0ZXJuYWxFbnRpdGllcyIsIm9yZGVyZWRSZXN1bHQiLCJwYXJzZVhtbCIsInByZXNlcnZlT3JkZXIiLCJ1bmRlZmluZWQiLCJhZGRFbnRpdHkiLCJrZXkiLCJ2YWx1ZSIsImluZGV4T2YiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */ function prettify(node, options) {\n    return compress(node, options);\n}\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */ function compress(arr, options, jPath) {\n    let text;\n    const compressedObj = {};\n    for(let i = 0; i < arr.length; i++){\n        const tagObj = arr[i];\n        const property = propName(tagObj);\n        let newJpath = \"\";\n        if (jPath === undefined) newJpath = property;\n        else newJpath = jPath + \".\" + property;\n        if (property === options.textNodeName) {\n            if (text === undefined) text = tagObj[property];\n            else text += \"\" + tagObj[property];\n        } else if (property === undefined) {\n            continue;\n        } else if (tagObj[property]) {\n            let val = compress(tagObj[property], options, newJpath);\n            const isLeaf = isLeafTag(val, options);\n            if (tagObj[\":@\"]) {\n                assignAttributes(val, tagObj[\":@\"], newJpath, options);\n            } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {\n                val = val[options.textNodeName];\n            } else if (Object.keys(val).length === 0) {\n                if (options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n                else val = \"\";\n            }\n            if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n                if (!Array.isArray(compressedObj[property])) {\n                    compressedObj[property] = [\n                        compressedObj[property]\n                    ];\n                }\n                compressedObj[property].push(val);\n            } else {\n                //TODO: if a node is not an array, then check if it should be an array\n                //also determine if it is a leaf node\n                if (options.isArray(property, newJpath, isLeaf)) {\n                    compressedObj[property] = [\n                        val\n                    ];\n                } else {\n                    compressedObj[property] = val;\n                }\n            }\n        }\n    }\n    // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n    if (typeof text === \"string\") {\n        if (text.length > 0) compressedObj[options.textNodeName] = text;\n    } else if (text !== undefined) compressedObj[options.textNodeName] = text;\n    return compressedObj;\n}\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\nfunction assignAttributes(obj, attrMap, jpath, options) {\n    if (attrMap) {\n        const keys = Object.keys(attrMap);\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            const atrrName = keys[i];\n            if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n                obj[atrrName] = [\n                    attrMap[atrrName]\n                ];\n            } else {\n                obj[atrrName] = attrMap[atrrName];\n            }\n        }\n    }\n}\nfunction isLeafTag(obj, options) {\n    const { textNodeName } = options;\n    const propCount = Object.keys(obj).length;\n    if (propCount === 0) {\n        return true;\n    }\n    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)) {\n        return true;\n    }\n    return false;\n}\nexports.prettify = prettify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvbm9kZTJqc29uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQSxTQUFTQyxJQUFJLEVBQUVDLE9BQU87SUFDN0IsT0FBT0MsU0FBVUYsTUFBTUM7QUFDekI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxTQUFTQyxHQUFHLEVBQUVGLE9BQU8sRUFBRUcsS0FBSztJQUNuQyxJQUFJQztJQUNKLE1BQU1DLGdCQUFnQixDQUFDO0lBQ3ZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixJQUFJSyxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsU0FBU04sR0FBRyxDQUFDSSxFQUFFO1FBQ3JCLE1BQU1HLFdBQVdDLFNBQVNGO1FBQzFCLElBQUlHLFdBQVc7UUFDZixJQUFHUixVQUFVUyxXQUFXRCxXQUFXRjthQUM5QkUsV0FBV1IsUUFBUSxNQUFNTTtRQUU5QixJQUFHQSxhQUFhVCxRQUFRYSxZQUFZLEVBQUM7WUFDbkMsSUFBR1QsU0FBU1EsV0FBV1IsT0FBT0ksTUFBTSxDQUFDQyxTQUFTO2lCQUN6Q0wsUUFBUSxLQUFLSSxNQUFNLENBQUNDLFNBQVM7UUFDcEMsT0FBTSxJQUFHQSxhQUFhRyxXQUFVO1lBQzlCO1FBQ0YsT0FBTSxJQUFHSixNQUFNLENBQUNDLFNBQVMsRUFBQztZQUV4QixJQUFJSyxNQUFNYixTQUFTTyxNQUFNLENBQUNDLFNBQVMsRUFBRVQsU0FBU1c7WUFDOUMsTUFBTUksU0FBU0MsVUFBVUYsS0FBS2Q7WUFFOUIsSUFBR1EsTUFBTSxDQUFDLEtBQUssRUFBQztnQkFDZFMsaUJBQWtCSCxLQUFLTixNQUFNLENBQUMsS0FBSyxFQUFFRyxVQUFVWDtZQUNqRCxPQUFNLElBQUdrQixPQUFPQyxJQUFJLENBQUNMLEtBQUtQLE1BQU0sS0FB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YWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXhtbC1wYXJzZXJANC4yLjUvbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL25vZGUyanNvbi5qcz9hNTZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IG5vZGUgXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9ucyBcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBwcmV0dGlmeShub2RlLCBvcHRpb25zKXtcbiAgcmV0dXJuIGNvbXByZXNzKCBub2RlLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICogQHBhcmFtIHtzdHJpbmd9IGpQYXRoIFxuICogQHJldHVybnMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzKGFyciwgb3B0aW9ucywgalBhdGgpe1xuICBsZXQgdGV4dDtcbiAgY29uc3QgY29tcHJlc3NlZE9iaiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhZ09iaiA9IGFycltpXTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BOYW1lKHRhZ09iaik7XG4gICAgbGV0IG5ld0pwYXRoID0gXCJcIjtcbiAgICBpZihqUGF0aCA9PT0gdW5kZWZpbmVkKSBuZXdKcGF0aCA9IHByb3BlcnR5O1xuICAgIGVsc2UgbmV3SnBhdGggPSBqUGF0aCArIFwiLlwiICsgcHJvcGVydHk7XG5cbiAgICBpZihwcm9wZXJ0eSA9PT0gb3B0aW9ucy50ZXh0Tm9kZU5hbWUpe1xuICAgICAgaWYodGV4dCA9PT0gdW5kZWZpbmVkKSB0ZXh0ID0gdGFnT2JqW3Byb3BlcnR5XTtcbiAgICAgIGVsc2UgdGV4dCArPSBcIlwiICsgdGFnT2JqW3Byb3BlcnR5XTtcbiAgICB9ZWxzZSBpZihwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1lbHNlIGlmKHRhZ09ialtwcm9wZXJ0eV0pe1xuICAgICAgXG4gICAgICBsZXQgdmFsID0gY29tcHJlc3ModGFnT2JqW3Byb3BlcnR5XSwgb3B0aW9ucywgbmV3SnBhdGgpO1xuICAgICAgY29uc3QgaXNMZWFmID0gaXNMZWFmVGFnKHZhbCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmKHRhZ09ialtcIjpAXCJdKXtcbiAgICAgICAgYXNzaWduQXR0cmlidXRlcyggdmFsLCB0YWdPYmpbXCI6QFwiXSwgbmV3SnBhdGgsIG9wdGlvbnMpO1xuICAgICAgfWVsc2UgaWYoT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDEgJiYgdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXSAhPT0gdW5kZWZpbmVkICYmICFvcHRpb25zLmFsd2F5c0NyZWF0ZVRleHROb2RlKXtcbiAgICAgICAgdmFsID0gdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXTtcbiAgICAgIH1lbHNlIGlmKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwKXtcbiAgICAgICAgaWYob3B0aW9ucy5hbHdheXNDcmVhdGVUZXh0Tm9kZSkgdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IFwiXCI7XG4gICAgICAgIGVsc2UgdmFsID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaWYoY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCAmJiBjb21wcmVzc2VkT2JqLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICBpZighQXJyYXkuaXNBcnJheShjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldID0gWyBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldLnB1c2godmFsKTtcbiAgICAgIH1lbHNle1xuICAgICAgICAvL1RPRE86IGlmIGEgbm9kZSBpcyBub3QgYW4gYXJyYXksIHRoZW4gY2hlY2sgaWYgaXQgc2hvdWxkIGJlIGFuIGFycmF5XG4gICAgICAgIC8vYWxzbyBkZXRlcm1pbmUgaWYgaXQgaXMgYSBsZWFmIG5vZGVcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNBcnJheShwcm9wZXJ0eSwgbmV3SnBhdGgsIGlzTGVhZiApKSB7XG4gICAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gPSBbdmFsXTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gIH1cbiAgLy8gaWYodGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgaWYodHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIpe1xuICAgIGlmKHRleHQubGVuZ3RoID4gMCkgY29tcHJlc3NlZE9ialtvcHRpb25zLnRleHROb2RlTmFtZV0gPSB0ZXh0O1xuICB9ZWxzZSBpZih0ZXh0ICE9PSB1bmRlZmluZWQpIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgcmV0dXJuIGNvbXByZXNzZWRPYmo7XG59XG5cbmZ1bmN0aW9uIHByb3BOYW1lKG9iail7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmKGtleSAhPT0gXCI6QFwiKSByZXR1cm4ga2V5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkF0dHJpYnV0ZXMob2JqLCBhdHRyTWFwLCBqcGF0aCwgb3B0aW9ucyl7XG4gIGlmIChhdHRyTWFwKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJNYXApO1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoOyAvL2Rvbid0IG1ha2UgaXQgaW5saW5lXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYXRyck5hbWUgPSBrZXlzW2ldO1xuICAgICAgaWYgKG9wdGlvbnMuaXNBcnJheShhdHJyTmFtZSwganBhdGggKyBcIi5cIiArIGF0cnJOYW1lLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBvYmpbYXRyck5hbWVdID0gWyBhdHRyTWFwW2F0cnJOYW1lXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2F0cnJOYW1lXSA9IGF0dHJNYXBbYXRyck5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xlYWZUYWcob2JqLCBvcHRpb25zKXtcbiAgY29uc3QgeyB0ZXh0Tm9kZU5hbWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByb3BDb3VudCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICBcbiAgaWYgKHByb3BDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgIHByb3BDb3VudCA9PT0gMSAmJlxuICAgIChvYmpbdGV4dE5vZGVOYW1lXSB8fCB0eXBlb2Ygb2JqW3RleHROb2RlTmFtZV0gPT09IFwiYm9vbGVhblwiIHx8IG9ialt0ZXh0Tm9kZU5hbWVdID09PSAwKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMucHJldHRpZnkgPSBwcmV0dGlmeTtcbiJdLCJuYW1lcyI6WyJwcmV0dGlmeSIsIm5vZGUiLCJvcHRpb25zIiwiY29tcHJlc3MiLCJhcnIiLCJqUGF0aCIsInRleHQiLCJjb21wcmVzc2VkT2JqIiwiaSIsImxlbmd0aCIsInRhZ09iaiIsInByb3BlcnR5IiwicHJvcE5hbWUiLCJuZXdKcGF0aCIsInVuZGVmaW5lZCIsInRleHROb2RlTmFtZSIsInZhbCIsImlzTGVhZiIsImlzTGVhZlRhZyIsImFzc2lnbkF0dHJpYnV0ZXMiLCJPYmplY3QiLCJrZXlzIiwiYWx3YXlzQ3JlYXRlVGV4dE5vZGUiLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJvYmoiLCJrZXkiLCJhdHRyTWFwIiwianBhdGgiLCJsZW4iLCJhdHJyTmFtZSIsInByb3BDb3VudCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/node2json.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nclass XmlNode {\n    constructor(tagname){\n        this.tagname = tagname;\n        this.child = []; //nested tags, text, cdata, comments in order\n        this[\":@\"] = {}; //attributes map\n    }\n    add(key, val) {\n        // this.child.push( {name : key, val: val, isCdata: isCdata });\n        if (key === \"__proto__\") key = \"#__proto__\";\n        this.child.push({\n            [key]: val\n        });\n    }\n    addChild(node) {\n        if (node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n        if (node[\":@\"] && Object.keys(node[\":@\"]).length > 0) {\n            this.child.push({\n                [node.tagname]: node.child,\n                [\":@\"]: node[\":@\"]\n            });\n        } else {\n            this.child.push({\n                [node.tagname]: node.child\n            });\n        }\n    }\n}\nmodule.exports = XmlNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QteG1sLXBhcnNlckA0LjIuNS9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIveG1sTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BO0lBQ0pDLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFLEVBQUUsNkNBQTZDO1FBQzlELElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLGdCQUFnQjtJQUNuQztJQUNBQyxJQUFJQyxHQUFHLEVBQUNDLEdBQUcsRUFBQztRQUNWLCtEQUErRDtRQUMvRCxJQUFHRCxRQUFRLGFBQWFBLE1BQU07UUFDOUIsSUFBSSxDQUFDRixLQUFLLENBQUNJLElBQUksQ0FBRTtZQUFDLENBQUNGLElBQUksRUFBRUM7UUFBSTtJQUMvQjtJQUNBRSxTQUFTQyxJQUFJLEVBQUU7UUFDYixJQUFHQSxLQUFLUCxPQUFPLEtBQUssYUFBYU8sS0FBS1AsT0FBTyxHQUFHO1FBQ2hELElBQUdPLElBQUksQ0FBQyxLQUFLLElBQUlDLE9BQU9DLElBQUksQ0FBQ0YsSUFBSSxDQUFDLEtBQUssRUFBRUcsTUFBTSxHQUFHLEdBQUU7WUFDbEQsSUFBSSxDQUFDVCxLQUFLLENBQUNJLElBQUksQ0FBRTtnQkFBRSxDQUFDRSxLQUFLUCxPQUFPLENBQUMsRUFBRU8sS0FBS04sS0FBSztnQkFBRSxDQUFDLEtBQUssRUFBRU0sSUFBSSxDQUFDLEtBQUs7WUFBQztRQUNwRSxPQUFLO1lBQ0gsSUFBSSxDQUFDTixLQUFLLENBQUNJLElBQUksQ0FBRTtnQkFBRSxDQUFDRSxLQUFLUCxPQUFPLENBQUMsRUFBRU8sS0FBS04sS0FBSztZQUFDO1FBQ2hEO0lBQ0Y7QUFDRjtBQUdBVSxPQUFPQyxPQUFPLEdBQUdkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXhtbC1wYXJzZXJANC4yLjUvbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL3htbE5vZGUuanM/ZGI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNsYXNzIFhtbE5vZGV7XG4gIGNvbnN0cnVjdG9yKHRhZ25hbWUpIHtcbiAgICB0aGlzLnRhZ25hbWUgPSB0YWduYW1lO1xuICAgIHRoaXMuY2hpbGQgPSBbXTsgLy9uZXN0ZWQgdGFncywgdGV4dCwgY2RhdGEsIGNvbW1lbnRzIGluIG9yZGVyXG4gICAgdGhpc1tcIjpAXCJdID0ge307IC8vYXR0cmlidXRlcyBtYXBcbiAgfVxuICBhZGQoa2V5LHZhbCl7XG4gICAgLy8gdGhpcy5jaGlsZC5wdXNoKCB7bmFtZSA6IGtleSwgdmFsOiB2YWwsIGlzQ2RhdGE6IGlzQ2RhdGEgfSk7XG4gICAgaWYoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSBrZXkgPSBcIiNfX3Byb3RvX19cIjtcbiAgICB0aGlzLmNoaWxkLnB1c2goIHtba2V5XTogdmFsIH0pO1xuICB9XG4gIGFkZENoaWxkKG5vZGUpIHtcbiAgICBpZihub2RlLnRhZ25hbWUgPT09IFwiX19wcm90b19fXCIpIG5vZGUudGFnbmFtZSA9IFwiI19fcHJvdG9fX1wiO1xuICAgIGlmKG5vZGVbXCI6QFwiXSAmJiBPYmplY3Qua2V5cyhub2RlW1wiOkBcIl0pLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5jaGlsZC5wdXNoKCB7IFtub2RlLnRhZ25hbWVdOiBub2RlLmNoaWxkLCBbXCI6QFwiXTogbm9kZVtcIjpAXCJdIH0pO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy5jaGlsZC5wdXNoKCB7IFtub2RlLnRhZ25hbWVdOiBub2RlLmNoaWxkIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBYbWxOb2RlOyJdLCJuYW1lcyI6WyJYbWxOb2RlIiwiY29uc3RydWN0b3IiLCJ0YWduYW1lIiwiY2hpbGQiLCJhZGQiLCJrZXkiLCJ2YWwiLCJwdXNoIiwiYWRkQ2hpbGQiLCJub2RlIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/fast-xml-parser@4.2.5/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\n");

/***/ })

};
;